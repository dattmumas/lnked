Step 5: Implement slug-based URLs for posts and profiles (friendly links)
Scope: Now that the layouts and groups are in place, we tackle the friendly URL goal: use usernames and post slugs in URLs instead of numeric or opaque IDs. This involves introducing new routes for user profiles (/@username) and for viewing posts by slug (/posts/[slug]), updating internal links to point to these, and setting up redirects for any old paths. We will also confirm that these slug routes work for both personal and collective content as intended.
Affected Files:
User profile by slug: The app already effectively supports /@username via middleware and a profile/[username] page
github.com
github.com
. We will formalize this. If not already done, ensure that the profile page is under the public group (it should have been moved in Step 1 to src/app/(public)/profile/[username]/page.tsx). Now, we may consider the /@username pattern. We cannot have an actual folder named @username in Next.js; instead, we rely on the middleware or we could create a dynamic catch-all route at the app root. The simpler approach is to keep the middleware approach: i.e. Next’s middleware intercepts any path starting with /@ and rewrites it to /profile/username
github.com
. This is already in place and can remain. We should double-check the middleware logic after our refactor: it was rewriting to /profile/${username}${rest}
github.com
. With profile now under (public), the actual served route is /profile/[username] in code, which still matches. So that continues to work. If we want to eliminate middleware and use purely Next routes, we might leave it as is because the @ in URL is a special case best handled in middleware. So no change for profiles, except perhaps removing the old /users/[id] route. (See Step 6 for cleanup.)
Post page by slug: Introduce a new [slug] route for posts under the public group. Create src/app/(public)/posts/[slug]/page.tsx. This page will retrieve a post by its slug and render it. We can base the implementation on the existing individual post pages. In fact, the code for src/app/posts/[postId]/page.tsx (personal post view)
github.com
github.com
 and src/app/collectives/[slug]/[postId]/page.tsx (collective post view)
github.com
github.com
 can be combined:
Use createServerSupabaseClient() to fetch the post where slug == params.slug. Select the necessary fields, including the author’s name and collective info. For example, .select('*, author:users!author_id(full_name, username), collective:collectives!collective_id(name, slug), likes(count)'). The unique index on posts.slug ensures only one post will be returned
github.com
.
If no post is found, return notFound() to trigger a 404. If found, determine if it’s a personal post or a collective post by checking post.collective_id. We can then render the content similarly to the existing pages: include the title, author name, publication date, reading time (there’s a helper calculateReadingTime() in the old pages we can reuse
github.com
), the <LexicalRenderer> for the post content
github.com
, and components like <PostReactionButtons>, <BookmarkButton>, and <CommentsSection> if those are part of the post view (they were on the collective post page
github.com
).
For collective posts, we might want to show a link to the collective. E.g., above the title, “Published in CollectiveName”. The existing collective post page didn’t explicitly do this, but it’s a nice touch to add since the URL no longer contains the collective slug. We can get the collective name/slug from the fetched data and include a small breadcrumb or badge linking to that collective’s page. (This is an enhancement aligning with clarity of navigation). If we don’t add it now, it could be added later; at minimum, ensure the user can navigate to the collective via the author or some link.
For personal posts, consider linking the author’s profile somewhere (perhaps the author’s name is a link to /@username). The data is available: we joined the author’s username in the query. Using that, we can link to /@author.username (which the middleware will handle). This keeps navigation cohesive.
Update internal links: Now we need to make sure the rest of the app points to these new slug routes. This means updating anywhere we link to a post or profile by ID. Key places:
The PostCard component currently builds a URL as /collectives/[slug]/[postId] or /posts/[postId] depending on context
github.com
. Change this logic. We now prefer slug: post.slug is available (assuming the Supabase types are updated; if not, we know the field exists). We can do const postUrl = \/posts/${post.slug}`;. Since slug is global, we do not need to include collective slug in the URL at all. So even for collective posts, post.slugis unique and routeable. We should remove thecollectiveSlug ? ... : ...conditional entirely or repurpose it: if for some reasonpost.slugis missing (older post without slug), we might fall back to the old path to avoid breakage. But ideally, after migrating, every post has a slug. To be safe, we can implement:const postUrl = post.slug ? `/posts/${post.slug}` : (collectiveSlug ? `/collectives/${collectiveSlug}/${post.id}` : `/posts/${post.id}`);. This ensures older content isn’t unreachable. In practice, this fallback can be removed once we are confident all posts have slugs. Also update any similar link construction in other components (perhaps CommentsSectionif it links to post, orRecentPostRow, etc.). The goal is that any “Read more” or post title click navigates to /posts/<slug>` going forward.
Profile links: Ensure when the app links to a user’s profile, it uses the @username format. The Navbar already uses a pattern like href={\/@${username}`}when highlighting the profile button:contentReference[oaicite:50]{index=50}. This indicates the Navbar (for logged in users) expects the profile route to be/@username. That’s good. We should double-check if anywhere in UI we link to a user profile by ID. Possibly the FollowButtonorUserMenumight have used/users/[id]. Search for any usage of /users/in the code. If found, replace with/@usernameor/profile/[username]`. For example, if there is a “View Profile” link in a dropdown, update it.
Redirect old post URLs: We have changed the primary route for reading posts. We should add redirects so that any existing links (or user bookmarks) to the old patterns still work. There are two old patterns:
Personal posts: /posts/<id> (the app had this route for individual posts).
Collective posts: /collectives/<collectiveSlug>/<id>.
We can handle these in Next.js middleware or config. Since we already use middleware, an easy solution is: in middleware.ts, detect if the path matches /posts/<uuid> and rewrite or redirect to the slug route. However, converting an ID to slug requires a lookup. A quick fix is to do a server-side redirect in the page instead. For example, we can keep the old src/app/posts/[postId]/page.tsx file but change its implementation to a redirect: fetch the post by id and then call redirect("/posts/" + post.slug). This way, if someone visits /posts/abcdef-123... it will bounce them to /posts/my-post-title. Similarly, for collective posts, we can modify src/app/collectives/[slug]/[postId]/page.tsx: after verifying the collective, fetch the post by ID and then redirect("/posts/" + post.slug). This ensures a smooth transition (and it’s SEO-friendly if we use a 301 redirect). We should also update next.config.ts redirects if needed: earlier, we had rules redirecting unknown root slugs to /collectives/slug
github.com
. We might add a rule to catch /collectives/:slug/:id and redirect to /posts/:id (which then immediately redirects to slug via page logic). This double hop is not ideal but acceptable short-term. Alternatively, have the config redirect directly to /posts/[slug] if we could determine slug in config (we can’t without a lookup). So the page-level redirect is fine.
Note: After this change, the primary way to view a post is /posts/<slug>. The old URLs will mostly be used via redirects. It may be wise to update any user-facing copy that mentions URLs (perhaps documentation or the README “Routing Updates” section) to mention the new scheme (e.g. “Posts now use slugs in URLs”). But that can be handled outside of code steps.
Test Updates: A lot of tests might be touched here because the user-facing URLs for posts are different:
Unit tests: If there are tests for utilities or components that construct URLs (for example, maybe tests for the togglePostLike action or any component that prints a link), update them to expect slug URLs. E.g. if a test was ensuring that PostCard link equals /posts/1234..., it should now expect /posts/my-slug. If tests compare full URLs, you might need to inject a dummy slug. The Supabase Database types should ideally be updated to include slug in posts.Row so that TypeScript catches places where post.slug is needed. Add a field in the test mocks for post objects.
E2E tests: These will require careful review. For example, the comment flow test currently clicks on the first post’s “Read more” link and then expects to be able to add a comment
github.com
. If that test was checking the URL pattern with a regex or something, it might need adjustment (it probably wasn’t explicitly asserting the URL, except expecting a redirect to sign-in on comment click). After our changes, when the test clicks “Read more,” the URL will be /posts/<slug> instead of /posts/<id>. If the test does something like await expect(page).toHaveURL(/posts/), it will still pass since the path contains "posts". But if it specifically looked for an ID format, we’d adjust it. Another potential change: if any test goes directly to a known post URL, we’d now use slug. For instance, if a test was like page.goto('/posts/newly-created-id') to verify content, it should instead navigate via slug. However, our tests likely simulate user actions rather than hardcoding IDs.
We should also test the redirect behavior manually or via a quick automated step: e.g. write a test that navigates to an old URL and assert it lands on the new slug URL. This could be a new test case: go to /posts/<id> and expect page.url() to end with /posts/<slug>. Similarly for collective. Ensuring these redirects work will protect SEO and existing links.
Expected Outcome: The application now uses human-friendly URLs for key content. User profiles are accessible at e.g. /@alice (which the middleware rewrites to the unified profile page), and posts can be read at URLs like /posts/why-i-love-tailwind instead of an opaque ID. This dramatically improves navigability and shareability. All internal links (in feeds, cards, emails if any, etc.) will point to the new slug routes. Old URLs for posts still function via redirects, so we haven’t broken any existing references. From a user perspective, nothing is lost – if they had a bookmark to a collective post under the old scheme, it seamlessly forwards to the new slug URL. From a code perspective, we’ve removed the duplication of having separate “personal vs collective” post view pages; there’s now a single posts/[slug] page that covers both cases. We also ensured consistency: for example, wherever a user’s name appears (like on a post or comment), clicking it will take you to /@username (the profile), providing a clear, memorable path. At this stage, navigation through the app should feel intuitive, and our route structure is nearly finalized, with only legacy cleanup remaining.
