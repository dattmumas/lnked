Task 7: Implement Page Break and Other Editor Node Improvements
Goal: Finalize the remaining custom editor nodes to ensure all listed editor features are operational. In particular, implement the Page Break node so authors can insert page breaks (useful for print or segmentation) into their posts, and review any other partially implemented nodes like layout items.
Scope & Actions:
PageBreakNode Implementation: Currently, PageBreakNode is a placeholder that just renders “[Page Break]” text
github.com
. Enhance this by giving it a proper representation. For example, render it as a horizontal rule or a dashed line with a “Page Break” label, so it’s visually distinct in the editor. In the node’s createDOM, create an element with a class (e.g., page-break) and some styling (maybe use CSS to represent a break line). In decorate(), you could return a React component if needed for richer display. Ensure that when exporting or serializing, it outputs a marker that can be recognized (the JSON export now includes "type": "pagebreak"
github.com
, which is fine).
Usage of Page Break: Hook up the slash command for page breaks. The slash menu already has an entry for "Page Break" which dispatches INSERT_PAGE_BREAK_COMMAND
github.com
. Similar to the layout, add a listener in PostEditor for this command: on trigger, insert a new PageBreakNode into the editor. After implementation, test that typing “/Page Break” inserts the break node and that it remains in the content. If the platform intends to support printing or splitting content by pages, this node will serve as a logical marker (even if actual print handling is outside scope, having the node in content is the first step).
LayoutItemNode (if not done in Task 6): If the multi-column from Task 6 wasn’t fully completed, ensure the LayoutItemNode is properly implemented. It was left as a TODO
github.com
. At minimum, give it a decorate() that returns a <div class="layout-item" /> or similar, and perhaps apply a class in createDOM for styling. This likely was addressed in Task 6, but double-check that each item node displays its children.
Review Other Custom Nodes: Go through the custom Lexical nodes in src/components/editor/nodes. Ensure each is functional or remove it if not used. For example, if there’s an ExcalidrawNode or TweetNode, verify that the slash menu can insert them and that they render (the dependencies like @excalidraw/excalidraw are present, so ensure usage is wired up). Any node with a placeholder or incomplete logic should either be finished or temporarily disabled from user access to avoid confusion.
Testing & UX for New Nodes: Test the editor with these new nodes in a variety of scenarios: editing, saving, reloading the post for editing, and rendering on the front-end. For the Page Break, confirm it shows appropriately in the published post (the front-end renderer might need to translate it to an <hr> or a styled divider). If needed, update the rendering logic (maybe in LexicalRenderer.tsx or wherever post content JSON is converted to JSX/HTML) to handle the new node types. By polishing these editor nodes, we ensure the “rich post editor” feature set is truly realized and stable for end-users.
