# Lnked Repository Structure and Analysis

## Repository Structure Overview

**Root Directory:**

- **package.json & pnpm config** ‚Äì Project metadata and dependencies for a Next.js 13 app (uses pnpm).
- **tsconfig.json** ‚Äì TypeScript config (defines @/_ as alias for ./src/_).
- **tailwind.config.ts** ‚Äì Tailwind CSS setup (content paths in src/app and src/components, extended theme colors, etc.).
- **postcss.config.mjs** ‚Äì PostCSS/Tailwind integration config.
- **eslint.config.mjs & .prettierrc** ‚Äì Linting/formatting configuration.
- **jest.config.js & jest.setup.ts** ‚Äì Unit test config (using Jest and React Testing Library).
- **playwright.config.ts** ‚Äì E2E test config (Playwright), points to tests/e2e (likely empty or placeholder).
- **middleware.ts** ‚Äì Next.js Middleware protecting routes. Redirects anonymous users from /dashboard, /posts/new, /chat, or post edit URLs to sign-in, and redirects logged-in users away from auth pages. Also rewrites /@username URLs to /profile/username.
- **next-env.d.ts** ‚Äì Next.js‚Äôs default types (autogenerated).
- **test-slash-command.js** ‚Äì _Dev/testing script_ for simulating the Lexical editor‚Äôs slash-command menu in the browser console (not imported by app code). _This is a standalone helper and not used in production._
- **.github/workflows/ci.yml** ‚Äì CI pipeline definition (installs deps, lints, tests, and builds on push/PR).

**/supabase Directory:**

- **config.toml** ‚Äì Supabase local dev config (ports, service flags, etc.).
- **migrations/** ‚Äì SQL migration scripts for the database schema:

  - _20250101000000_initial_schema.sql_ ‚Äì Creates core tables: users, collectives, posts, comments, follows, etc..
  - _20250103000000_collective_invites.sql_ ‚Äì Adds invite tables for collectives (managing membership invitations).
  - _20250202000000_create_chat_system.sql_ ‚Äì Sets up tables for a chat feature (likely messages, threads, etc.).
  - _20250523041324_fix_follows_table_constraints.sql_ ‚Äì Schema tweaks (e.g. fixing foreign keys in follows).

- **seed.sql** ‚Äì Seed data script (referenced in config), used to populate initial data on db reset.
  _These SQL files define the backend data model that the app relies on (users, posts, subscription status, etc.)._

**Static Assets (/public):**

- **LICENSE.md** ‚Äì MIT License attribution for Bootstrap Icons (placed in public so it‚Äôs included in deployments).
- **Images and media** ‚Äì e.g. SVGs like 3-columns.svg (and likely logos or favicons). These files are served directly; for instance, the landing page may reference SVG patterns for styling. _(If any images aren‚Äôt actually referenced in the code, they could be legacy assets.)_

## Next.js App (src/app)

This project uses Next.js App Router (with React Server Components). It organizes pages into route groups for public vs. authenticated content:

- **Global App Setup:**

  - **src/app/layout.tsx** ‚Äì The root layout applied to all pages. Imports global CSS and wraps content with the theme provider and a persistent header. The header is the **ModernNavbar** component (which adjusts nav links based on user auth state). The layout fetches the current user via Supabase on the server and passes user info to the navbar.
  - **src/app/error.tsx** ‚Äì A global error boundary for the app (to display fallback UI on uncaught errors).
  - **Middleware (see root)** ‚Äì Enforces auth on certain routes and rewrites vanity profile URLs.

- **Public Group ‚Äì src/app/(public)/‚Ä¶:** Routes accessible without login.

  - **page.tsx** ‚Äì The **landing page**, showing the marketing homepage for Lnked. It‚Äôs a client component (likely for interactive effects). The landing page implements custom cursor, parallax scroll, and animated sections in-line. It likely contains multiple sections such as a hero, feature highlights, quotes, etc. _Notably, the repository also includes separate section components (e.g. NewspaperHero, DigitalPrintroom, NewsstandFooter in src/components/landing/sections) that appear to be designed for the landing page. However, the current landing page code implements these effects internally and does not import those section components._ (This suggests those landing/sections/\*.tsx files might be **unused** remnants of an earlier design approach.)
  - **discover/page.tsx** ‚Äì The **‚ÄúDiscover Collectives‚Äù** page for browsing content publicly. It fetches recommended collectives from an API and lists them. Each recommendation is rendered via **CollectiveCard**, and a **LoadMoreButton** appears if pagination is available. The data fetching is done by fetchRecommendations() in the lib (which calls a now-expected /api/recommendations endpoint). _If the /api/recommendations route isn‚Äôt implemented, this page‚Äôs data may currently be static or return an error alert._ The CollectiveCard component is reused from the dashboard components (it displays collective info and possibly a follow/subscribe UI).
  - **discover/\_actions.ts** ‚Äì Server actions for the discover page. (Possibly used for giving feedback on recommendations or loading additional data). If not referenced, it could be a placeholder.
  - **profile/\[username]/page.tsx** ‚Äì The **public profile** page for a user, reached via /profile/username (or /@username via rewrite). It loads the user‚Äôs profile info (by username or ID) and their content. The page uses **ProfileFeed** to show the user‚Äôs posts, and includes interactive elements: a **FollowButton** to follow the user, and a **SubscribeButton** to subscribe to the user‚Äôs newsletter. It also displays follower and subscriber counts and whether the current viewer already follows the user. If the profile is not found, it returns a 404 via notFound().
  - **collectives/\[slug]/page.tsx** ‚Äì The **public collective** page for a newsletter/collective (accessible at /collectives/[slug]). It is analogous to a profile page but for a collective. It fetches collective details by slug, plus member count and follower count. The UI similarly uses **ProfileFeed** to list recent posts in that collective, and shows a **FollowCollectiveButton** (to follow the collective) and a **SubscribeButton** to subscribe to its newsletter. If the user viewing is the owner or a member, they might see additional info (the code checks if the current user is following or if they are the owner for certain interactions).
  - _(Potential public routes that appear planned but not fully present include /api/recommendations for discover. Since fetchRecommendations calls this API but we don‚Äôt see a corresponding src/app/api/recommendations in the repo, this might be an unimplemented feature. Similarly, section components for the landing page exist but aren‚Äôt used, as noted.)_

- **Auth Group ‚Äì src/app/(auth)/‚Ä¶:** Dedicated routes for authentication. These have minimal layout and redirect logic (the middleware prevents access when logged in).

  - **sign-in/page.tsx** ‚Äì The **Sign In** page (server component). It simply renders the client-side form component **SignInPageClient**.
  - **sign-in/SignInPageClient.tsx** ‚Äì The interactive login form logic. It uses Supabase client auth to sign users in with email/password. On success, it refreshes and redirects to the dashboard. It leverages a reusable **AuthForm** component for the UI of the form.
  - **sign-up/page.tsx** ‚Äì The **Sign Up** page (server component) rendering **SignUpPageClient**.
  - **sign-up/SignUpPageClient.tsx** ‚Äì The sign-up form logic. It calls Supabase to create a new user account (optionally capturing full name). It then either prompts email confirmation or, if auto-confirmed, redirects to dashboard. It also uses **AuthForm** for the form UI, with mode="signUp" to include a ‚ÄúFull Name‚Äù field.

- **Editor Group ‚Äì src/app/(editor)/‚Ä¶:** Routes for the **rich-text editor** interface (for creating or editing posts). These are separated into their own route group (likely so they can have a different layout or avoid the main nav, enabling a distraction-free editor). The middleware ensures only authenticated users can access these URLs.

  - **posts/new/page.tsx** ‚Äì The page to **create a new post**. It ensures the user is logged in and optionally associates a new post with a collective if ?collectiveId= is provided in the URL. It fetches the collective data and permission if present (allowing only members with roles to post in a collective). Finally, it renders the **NewPostForm** editor component with appropriate page title (‚ÄúNew Post‚Äù or ‚ÄúNew Post in \[Collective]‚Äù).
  - **posts/new/NewPostForm.tsx** ‚Äì A client component implementing the post creation form (the rich text editor and associated fields). It uses React Hook Form with a Zod schema for validation (from postSchemas in src/lib/schemas) and Lexical for the content editor. Key sub-components include:

    - **EditorLayout & PostEditor** ‚Äì The Lexical editor UI for writing content. NewPostForm mounts a <PostEditor> component (a wrapper around a dynamic Lexical playground editor) with an EMPTY_LEXICAL_STATE as initial content.
    - **PublishSettingsCard** ‚Äì UI for publication settings (e.g., post status: draft/published/scheduled).
    - **SEOSettingsDrawer** ‚Äì A slide-out drawer for editing SEO title & meta description.
    - **QuickActionsBar** ‚Äì A toolbar with quick formatting or insert actions.
      The form state tracks title, subtitle, content JSON, etc., and uses an onChange from the editor to update the content field. On submit, it calls a server action **createPost** (imported from src/app/actions/postActions.ts) to save the post in the database. An optimistic UI is used for saving: there‚Äôs even an auto-save draft mechanism (performAutosave) that periodically calls **createPost** to save progress as a draft. If creation is successful, the form shows a success message and redirects to the dashboard or the new post‚Äôs page (the code currently navigates to /dashboard after creation).

  - **posts/\[slug]/edit/page.tsx** ‚Äì The page to **edit an existing post**. It‚Äôs parameterized by post ID or slug. It fetches the post data from Supabase on the server and checks that the current user has permission to edit it (either they are the author or an admin/editor of the collective it belongs to). If not authorized, it returns notFound() (which effectively acts like an access denied). If authorized, it prepares the post data and uses it to render **EditPostForm** with an appropriate page title (‚ÄúEdit Post‚Äù or ‚ÄúEdit Post in \[Collective]‚Äù).
  - **posts/\[slug]/edit/EditPostForm.tsx** ‚Äì Similar to NewPostForm, but initialized with existing post data. It populates the form‚Äôs default values with the post‚Äôs title, content, etc.. It also determines initial status (draft/published/scheduled) based on published_at and is_public flags. The component includes Save and Delete functionality: it imports **updatePost** and **deletePost** actions from postActions. When the user makes changes, it calls updatePost via a React Hook Form submit; if the user clicks delete, it calls deletePost (likely triggering removal and redirect to dashboard). The UI and sub-components (EditorLayout, PostEditor, SEO drawer, etc.) mirror those in NewPostForm, providing a consistent editing experience.

  _Both NewPostForm and EditPostForm heavily rely on the **Lexical editor** integration for rich text. They dynamically import an internal LexicalPlaygroundEditorInternal component and related CSS (toolbar, menus) via PostEditor. This indicates the editor is based on Lexical‚Äôs official ‚Äúplayground‚Äù example, with custom plugins for slash commands, tables, markdown, etc., included in the codebase (see **Lexical Integration** under components)._

- **Dashboard ‚Äì src/app/dashboard/‚Ä¶:** Routes for the **user dashboard**, available after login. The entire /dashboard path is protected by the middleware. The dashboard has its own layout that injects the sidebar navigation.

  - **dashboard/layout.tsx** ‚Äì Wraps all dashboard sub-pages in a DashboardShell UI. On the server, it fetches the logged-in user‚Äôs owned and joined collectives to pass into the sidebar. If no session, it redirects to sign-in (defense in depth aside from middleware). It then composes the page with <DashboardShell userCollectives={‚Ä¶}>{children}</DashboardShell>. The **DashboardShell** component (in components/app/dashboard/organisms) uses those collectives to populate the sidebar navigation (links to each collective‚Äôs management section) and likely displays the user‚Äôs name/email.
  - **dashboard/page.tsx** ‚Äì The **main dashboard home**. It provides an overview of the user‚Äôs content and stats. On load, it fetches: the user‚Äôs profile (username), their owned collectives, their personal posts (posts not in a collective), and some statistics like subscriber count, follower count, total views, likes, etc. (possibly via PostgREST count queries). It then renders a page with:

    - Quick action cards or alerts (for example, to prompt the user to do something if needed).
    - A **StatsRow** component showing key metrics (subscribers, followers, etc.). The code uses the fetched counts and any data like viewsData or likesData to populate this. **StatsRow** (in components) likely displays icons and counts (e.g. ‚Äúüíå X Subscribers, üë• Y Followers, üëÅÔ∏è Z Views‚Äù).
    - A **RecentPostRow** listing the user‚Äôs latest personal posts (limited to 3). Each entry might include a link to edit or view the post. RecentPostRow is likely a small component in the dashboard organisms that formats a single post entry (title and date, possibly status).
    - Links/buttons to manage content: e.g., a ‚ÄúNew Post‚Äù button or links to the full posts list. The page code fetches all personal posts (used for recent list) and all owned collectives (for display and navigation).
    - If any errors occurred in fetching data, it shows an error message (the code logs and returns a failure notice if needed).

  - **dashboard/posts/page.tsx** ‚Äì The **‚ÄúMy Posts‚Äù** page showing all posts the user has authored (both personal and within collectives). It queries Supabase for all posts where author_id is the user, joining on collectives and reaction counts. It also fetches the list of collectives the user can post to: all collectives they own plus those where they have roles like admin/editor/author. With these, the page likely renders two things:

    - A list of posts (using a **PostListItem** component for each). Indeed, it imports **PostListItem** from components/app/dashboard/posts/PostListItem and probably maps over the posts data to render each item. PostListItem might show the title, status, date, and perhaps edit/delete actions for each post.
    - A ‚ÄúNew Post‚Äù call-to-action. The page UI includes a button that links to /posts/new (the editor) or allows choosing a collective to post in. In fact, the code prepares publishingCollectives ‚Äì a combined list of collectives to which the user can contribute. This suggests the UI might present an option like ‚ÄúWrite in \[Collective]‚Äù vs personal. Possibly the page shows a dropdown or list of collectives with a link to create a post (the **Plus** icon is imported for a button).
    - This page likely uses the same DashboardShell layout, so the sidebar is visible.

  - **dashboard/collectives/page.tsx** ‚Äì The **‚ÄúMy Collectives‚Äù** page listing all collectives the user owns or is a member of. It fetches both sets on the server: collectives where owner_id = user.id (with a count of subscribers for each) and collectives where the user is in collective_members (joined collectives, filtering out ones they own). The page then renders:

    - A header with title ‚ÄúMy Collectives‚Äù and a **Create New Collective** button. The button links to the new collective form at /dashboard/collectives/new.
    - A list of the user‚Äôs collectives. For each, it likely uses **DashboardCollectiveCard** (imported at top) to display the collective‚Äôs name, description, and subscriber count. The code organizes data into ownedCollectives and eligibleMemberships then checks if any exist. If none, it might show a placeholder message. Otherwise, it outputs a list of cards.
    - _Unused check:_ A similar component **CollectiveCard** (without the ‚ÄúDashboard‚Äù prefix) also exists in components/app/dashboard/collectives. In the Discover page, they actually use CollectiveCard for recommendations. So **CollectiveCard** is used on public-facing lists (showing collective info plus perhaps a subscribe button), whereas **DashboardCollectiveCard** is used in the user‚Äôs dashboard list (maybe with management controls). Both are actively referenced.

  - **dashboard/collectives/new/page.tsx** ‚Äì The page for **creating a new collective** (accessible via the ‚ÄúCreate New Collective‚Äù button). It verifies the user is logged in on the server, then renders the form component **NewCollectiveForm**.
  - **dashboard/collectives/new/NewCollectiveForm.tsx** ‚Äì Client component for the ‚ÄúNew Collective‚Äù form. It includes fields for name, slug, and description. The slug is auto-generated as the user types the name (lowercasing and hyphenating the name). On submission, it calls a server action **createCollective** (imported from the local \_actions.ts) to insert a new collective in the DB. During submit, it optimistically clears the form and shows a success message, then redirects (currently back to /dashboard) after a short delay. If there‚Äôs an error (like slug taken), it displays the error message.
  - **dashboard/collectives/new/\_actions.ts** ‚Äì Server action module for creating collectives. It validates the input with Zod (name/slug constraints). It checks slug uniqueness and inserts the new collective into the collectives table. Upon success, it also inserts a record into collective_members to make the owner an admin member of their collective. Finally, it triggers revalidation of the dashboard pages so the new collective appears immediately in lists.
  - **dashboard/collectives/\[collectiveId]/page.tsx** ‚Äì The **Collective Dashboard** page for managing a specific collective (URL: /dashboard/collectives/[id]). It ensures the user is authenticated and that the collective exists. It then simply renders a dashboard welcome with the collective‚Äôs name and a few management buttons. Specifically, it shows: ‚ÄúAdd Post‚Äù (links to /posts/new?collectiveId=<id>), ‚ÄúMembers‚Äù (links to the member management page), and if the user is the owner, also ‚ÄúSettings‚Äù and ‚ÄúSubscribers‚Äù links. This page is essentially a menu hub; the real functionality lies in the sub-routes.
  - **dashboard/collectives/\[collectiveId]/manage/members/** ‚Äì **Collective Member Management** section. This likely includes:

    - _InviteMemberForm.tsx_ ‚Äì A form to invite a new member by email. It probably uses a server action (like inviteUserToCollective from collectiveActions.ts) to send an invite (the invite would create a record in a invites table with a code, etc.). In collectiveActions, we indeed see an inviteUserToCollective function that verifies ownership and checks for the user‚Äôs email in the DB, then likely creates an invite entry and triggers an email (Stripe or Supabase email, possibly via supabaseAdmin). The form component would gather an email and role, call this action, and display success or field errors accordingly.
    - _ManageMembersClientUI.tsx_ ‚Äì A client-side component to display and manage the collective‚Äôs member list. It likely lists current members and their roles, and includes the InviteMemberForm to add new ones. It might allow removing members or changing roles. It‚Äôs imported on the member management page.
    - _manage/members/page.tsx_ ‚Äì (Not explicitly seen, but inferred) a server page that fetches current members and renders the ManageMembersClientUI. It might pass initial server-fetched data (like the list of members) or rely on client-side fetching. If this page is missing from the repo, the navigation link to ‚ÄúMembers‚Äù will lead to a 404. Given the presence of the form/UI components, it‚Äôs likely intended but may be incomplete. **If no page.tsx is present for this route, the components under /manage/members are currently unused.**

  - **dashboard/collectives/\[collectiveId]/settings/** ‚Äì **Collective Settings** page (only for owners). The link is provided in the collective dashboard page. This would contain forms to update collective info (name, description, branding, etc.). We see in collectiveActions.ts references to a CollectiveSettingsServerSchema, suggesting a schema for settings form, and likely functions to update collective details or manage subscription plans. The actual page or form component for settings isn‚Äôt explicitly found, but we can infer it‚Äôs planned. (Likely similar to user profile settings but for a collective.)
  - **dashboard/collectives/\[collectiveId]/subscribers/** ‚Äì **Subscriber list** page (for owners to see who subscribed to their collective‚Äôs newsletter). The link exists in UI. There may be a page to list subscribers and perhaps manage subscription tiers, but no explicit file was identified via search. Possibly intended but not yet implemented fully.
  - **dashboard/profile/** ‚Äì It appears user profile editing is handled elsewhere (likely in a settings page separate from the main dashboard). We did not see an explicit /dashboard/profile route; instead, profile editing might be a modal or separate ‚ÄúSettings‚Äù section (not clearly present in main nav code). The user‚Äôs **profile update** is handled by server action updateUserProfile in userActions.ts, and might be invoked from a form in a component (perhaps a ‚ÄúProfileSettings‚Äù form). Since the question didn‚Äôt show a dedicated page, this might be integrated into the general dashboard or not yet built.

- **Invite Route ‚Äì src/app/invite/[inviteCode]/page.tsx:**
  A standalone route to handle **collective invite links**. If a user receives an invite link (with a unique code), it directs here. The page checks for a logged-in user; if not, it redirects them to sign in and then back to the invite URL. If logged in, it calls the server action **acceptCollectiveInvite** from memberActions.ts to process the invite. The result (success or error) is then displayed in a simple message, and the user can click ‚ÄúGo to Dashboard‚Äù afterward. This flow leverages the invite system: acceptCollectiveInvite likely verifies the code, adds the user to the collective‚Äôs members, and marks the invite as used. (We see memberActions.ts referenced, presumably containing this logic.)

- **API Routes ‚Äì src/app/api/‚Ä¶:** Serverless API endpoints for certain operations (called by client components or external webhooks). Notable API routes:

  - **api/collectives/route.ts** ‚Äì GET endpoint that returns a list of all collectives (with basic info and owner‚Äôs name). This provides public collective data, possibly used for search or discovery (though the Discover page currently uses recommendations instead). The code selects id, name, slug, description, created_at, owner info from the database and returns JSON. (POST is not handled here ‚Äì new collectives are created via server action instead.)
  - **api/collectives/\[collectiveId]/stripe-onboard/route.ts** ‚Äì POST endpoint for **Stripe Connect onboarding**. When a collective owner wants to set up payments (to receive subscription revenue), the frontend likely calls this route. It checks the request user‚Äôs auth and ownership of the collective, then uses the Stripe SDK (via getStripe()) to create or reuse a connected Stripe Account. It stores the stripe_account_id in the DB using the service role client (bypassing RLS). Then it creates an account onboarding link (with return and refresh URLs back to the app‚Äôs collective settings page) and returns the URL for the front-end to redirect the owner to Stripe‚Äôs onboarding flow.
  - **api/collectives/\[collectiveId]/plans/route.ts** ‚Äì Likely intended for fetching available subscription plans for a collective. (We saw a reference in search results). Possibly returns pricing tiers (this is suggested by SubscribeButton having optional tiers prop). This route might not be fully implemented or was planned to interface with Stripe prices. If unimplemented, subscribing uses a default price.
  - **api/subscribe/route.ts** ‚Äì POST endpoint to **create a Stripe Checkout session** for a new subscription. The **SubscribeButton** uses this when a user clicks ‚ÄúSubscribe‚Äù. The handler expects priceId, targetEntityType (‚Äúuser‚Äù or ‚Äúcollective‚Äù), and targetEntityId in the request body. It ensures the user is logged in (via Supabase session), then finds or creates a Stripe Customer for the user (it checks a customers mapping table via supabaseAdmin). Next, it creates a Checkout session for the given price and sets metadata about the target entity being subscribed to. The session URL is returned; the client then router.push(session.url) to redirect the user to Stripe. (Errors are handled by returning JSON with an error message.)
  - **api/stripe-webhook/route.ts** ‚Äì Endpoint for **Stripe Webhook events** (e.g. subscription payments, cancellations). Stripe calls this URL (configured via STRIPE_WEBHOOK_SECRET) with events. The handler validates the signature and then switches on event types. Relevant events include checkout.session.completed and subscription status changes. For example, on checkout.session.completed for a subscription, the code upserts the customer ID into the customers table and logs that a subscription was created (metadata includes which user and which entity was subscribed). Other cases likely handle updating the subscriptions table in the database to reflect new or cancelled subscriptions. The webhook uses the supabaseAdmin client to perform inserts/updates (bypassing RLS) to tables like subscriptions, customers, etc. After processing, it returns a 200 JSON so Stripe knows the webhook was handled.
  - **api/recommendations** ‚Äì _(Possibly missing)_: As discussed, the Discover page expects an /api/recommendations that returns recommended collectives. It would likely query a Postgres function or use some simple logic (e.g., latest or popular collectives with a score). If it existed, fetchRecommendations would call it and receive { recommendations, nextCursor }. The absence of this route in the repo suggests this feature might be incomplete or implemented as a placeholder always returning empty recommendations.

## Components and Utilities

**UI Components (Reusable):** Located mainly in src/components/ui/. These are low-level styled components (many adapted from Radix UI + Tailwind, similar to shadcn UI library). They are imported throughout the app for consistent styling:

- **Button (ui/button.tsx):** Styled <button> component with variants (uses Radix <Slot> for polymorphism likely). Used everywhere for actions (e.g. in Navbar, forms, etc.).
- **Card (ui/card.tsx):** Card container with subcomponents ‚Äì CardHeader, CardContent, CardFooter, CardTitle, CardDescription ‚Äì providing a consistent panel style. Utilized in AuthForm, Dashboard stats, etc.
- **Input (ui/input.tsx) and Label (ui/label.tsx):** Form input field and label. Used in auth forms, collective forms, profile forms.
- **Alert (ui/alert.tsx):** A callout box with AlertTitle and AlertDescription. Used for error messages on pages (e.g., Discover error, invite success/error).
- **Avatar (ui/avatar.tsx):** Displays user avatars (using @radix-ui/react-avatar under the hood). Exports <Avatar>, <AvatarImage>, and <AvatarFallback> for when no image. Navbar uses this for the user‚Äôs profile picture in the mobile menu.
- **Badge (ui/badge.tsx):** Small badge label (used for notification count on bell icon, and to mark ‚ÄúFeatured‚Äù post in profile feed).
- **Dropdown Menu (ui/dropdown-menu.tsx):** Wrapper around Radix DropdownMenu for user menus. The Navbar uses it for the user profile menu and notifications dropdown.
- **Sheet (ui/sheet.tsx):** A side panel component (Radix Drawer/Sheet). Used for the mobile sidebar menu (Navbar‚Äôs hamburger opens a Sheet on small screens).
- **Textarea (ui/textarea.tsx):** Multi-line text input, used for descriptions or content inputs (e.g., collective description field in NewCollectiveForm).
- **ReadOnlyLexicalViewerClient.tsx:** A specialized component to render Lexical rich-text content in read-only mode. This would take a Lexical JSON and output formatted HTML (likely via Lexical‚Äôs read-only editor). It‚Äôs probably intended for viewing posts (e.g., if a post detail page existed) or previewing content. **However, since there‚Äôs currently no page that displays a full post‚Äôs content (no /posts/[id] page implemented), this component might not be used yet ‚Äì a candidate for unused code.**

**App-Specific Components:** In src/components/app/, grouped by feature:

- **Navbar & Navigation:**

  - **ModernNavbar.tsx** ‚Äì The main navigation bar (persistent across pages via RootLayout). It‚Äôs a client component with state to handle user login status and menus. It defines two sets of nav items: publicNavItems (e.g. Discover) and authenticatedNavItems (e.g. Dashboard). In the JSX, it renders user ? authenticatedNavItems : publicNavItems to show different links depending on auth. It also conditionally shows a ‚ÄúWrite‚Äù button and notifications icon when a user is logged in. On the right side, if not logged in, it shows ‚ÄúSign In‚Äù and ‚ÄúGet Started‚Äù buttons. The component interacts with Supabase to listen for auth changes: it calls supabase.auth.getSession() on mount and updates the user state (possibly to update the nav after initial render). It also loads some user profile metadata (like avatar URL and full name for the mobile menu) after login.
  - **Sidebar (DashboardSidebar.tsx & SidebarNav.tsx)** ‚Äì Used inside DashboardShell to render the sidebar menu for dashboard pages. **DashboardShell.tsx** (an ‚Äúorganism‚Äù in dashboard components) composes the overall private layout: likely includes the Sidebar (with links to ‚ÄúMy Posts‚Äù, ‚ÄúMy Collectives‚Äù, and each collective the user is part of) and wraps children in a content area. _We see it imported in dashboard/layout.tsx_. **SidebarNav.tsx** might define the list of navigation links for the sidebar (e.g., Home, Posts, each Collective). These components use the userCollectives array passed from layout to list collectives dynamically.
  - **StatsRow\.tsx & RecentPostRow\.tsx** ‚Äì Part of dashboard home, as mentioned. StatsRow likely shows a row of statistic cards or badges (using Card and maybe AlertCircle/Info icons). RecentPostRow displays a single recent post (we see it imported in dashboard page and used presumably in a list).

- **Auth & Profile:**

  - **AuthForm.tsx** ‚Äì A reusable form component for sign-in/sign-up flows. It renders a Card with an email and password field (and full name when mode==="signUp"). It also shows an error Alert if error prop is provided (for auth errors) and a success/message if needed. At the bottom, it shows a submit Button and maybe a link (‚ÄúNo account? Sign up‚Äù or vice versa) depending on mode. This component is used by both SignInPageClient and SignUpPageClient, simply configured via props.
  - **FollowButton.tsx** ‚Äì A button to follow/unfollow a user. It likely toggles a follow relationship in the follows table. The profile page uses it, passing the viewed user‚Äôs ID into FollowButton. The implementation likely calls a serverless function or uses Supabase client to insert/delete a follow record and updates UI text (e.g., ‚ÄúFollow‚Äù vs ‚ÄúFollowing‚Äù). (We did not open it, but it's referenced in Profile page).
  - **FollowCollectiveButton.tsx** ‚Äì Similar to FollowButton but for collectives. Used on the collective public page to let a user follow a collective (follows table with following_type='collective').
  - **SubscribeButton.tsx** ‚Äì A complex button for subscription actions (subscribe to a newsletter). Found in components/app/newsletters/molecules/. It handles showing subscription options and initiating the Stripe checkout. When clicked, if multiple pricing tiers are available, it can show a dropdown (the code has state for showOptions and a tiers list). For MVP it defaults to one tier (a default price). On click, it checks if the user is logged in (fetching current user via Supabase browser client) and if not, redirects to sign-in with a redirect back. If logged in, it calls fetch('/api/subscribe') with the target entity info. The response is expected to be a Stripe Checkout Session; if a URL comes back, it redirects the browser there. Any error is caught and displayed in an Alert inside the component (it keeps an error state). After Stripe checkout, the webhook will update the DB and on return the app can show the updated status (the profile/collective page might query subscription status to show ‚ÄúSubscribed‚Äù). SubscribeButton is used on both profile and collective pages (targetEntityType is passed as 'user' or 'collective').
  - **ProfileFeed.tsx** ‚Äì Displays a user‚Äôs or collective‚Äôs list of posts, with filtering. It takes in an array of posts (posts prop) and optional pinnedPost (for a highlighted post). It also receives microPosts (short form content) ‚Äì these might be like tweet-style updates to show in a sidebar (if used). The component categorizes posts into types ('articles', 'videos', 'audio') based on content: it checks the Lexical content string for <audio or <iframe tags to classify as audio or video posts. It uses state activeTab to filter between showing all posts vs only videos vs only audio posts. The UI:

    - If there are any audio-type posts, it renders an **AudioSlider** at the top. The AudioSlider component (in profile/AudioSlider.tsx) creates a horizontal scroll list of posts that have audio content ‚Äì likely with a placeholder or thumbnail and title for each. Each item links to either the post‚Äôs slug URL or if the post has no slug, to a collective-specific URL (/collectives/[slug]/[postId]) if it‚Äôs in a collective. (This suggests posts in collectives might not have global slugs, so they need collective context to view.)
    - It shows a **ContentFilterTabs** component (in profile/ContentFilterTabs.tsx) ‚Äì likely a set of tabs or buttons to switch between ‚ÄúAll | Articles | Videos | Audio‚Äù. This updates activeTab state.
    - If there is a pinned post (featured), it renders it separately at the top with a ‚ÄúFeatured‚Äù badge and uses **PostCard** to display it.
    - It then maps over the remaining filtered posts and outputs a **PostCard** for each. PostCard is used to show a preview of a post (title, excerpt, maybe like count).
    - On the right side, ProfileFeed includes the **MicrothreadPanel** ‚Äì likely a sidebar panel showing micro posts (short updates). MicrothreadPanel (in profile/MicrothreadPanel.tsx) might list brief text posts or comments ‚Äì potentially an experimental feature for short-form content. (Given the naming and the MicroPost type, it‚Äôs like a small ‚Äúthread‚Äù of mini posts).
    - Overall, ProfileFeed provides a comprehensive profile timeline, mixing full articles and possibly shorter content. It relies on PostCard to handle interactions like likes.

  - **PostCard.tsx** ‚Äì This component (in components/app/posts/molecules/) displays a post summary card on profile/collective feeds and in lists. It receives a post object (with possibly augmented fields like like_count and a current_user_has_liked flag) and an optional collectiveSlug (if the post is part of a collective). It constructs the link to the post: if the post has a slug, it uses /posts/[slug]; if not but it has a collectiveSlug, it links to /collectives/[slug]/[postId]; otherwise a generic /posts/[id]. This ensures even un-slugged posts in collectives can be accessed via the collective route. PostCard displays the title, an excerpt of content (truncated), the publish date, and includes an inline Like button. Instead of a separate Like component, it embeds a small heart icon button: it imports **togglePostLike** action and calls it on click. When clicked, it optimistically updates the like count and ‚Äúliked‚Äù state in the UI immediately, then awaits the result of togglePostLike(post.id, collectiveSlug) to confirm or rollback. If the user is not logged in (!currentUserId), it alerts prompting sign-in instead of toggling. This component interacts with **likeActions.ts** via the imported action. (It supersedes the need for a separate PostLikeButton component; indeed, a standalone PostLikeButton.tsx exists in the repo, but since PostCard handles the like internally, that file is likely unused and can be removed.)
  - **PostListItem.tsx** ‚Äì Likely similar to PostCard but in list form for the dashboard ‚ÄúMy Posts‚Äù page. It might be a condensed row showing a post‚Äôs title, status, and edit link. The dashboard/posts page imports and uses it. It presumably calls edit actions or navigates to the editor if the user clicks it. (Without seeing its code, we deduce its role from context.)

- **Lexical Editor Integration:**
  The project incorporates a rich text editor using Facebook‚Äôs Lexical library. The implementation is largely based on Lexical‚Äôs example ‚Äúplayground‚Äù code, adapted into the app‚Äôs structure:

  - **Lexical Playground Components (src/components/lexical-playground/‚Ä¶):** This folder contains a lot of code cloned from the Lexical demo. It has subfolders for custom nodes (e.g., AutocompleteNode, InlineImageNode, PageBreakNode), plugins (AutocompletePlugin, ToolbarPlugin, DraggableBlockPlugin, etc.), a theme CSS, and an App.tsx and appSettings.ts which were part of the original playground app. In our app, however, Lexical is used within the **PostEditor**. The code centralizes actual usage in:

    - **PostEditor.tsx** ‚Äì as mentioned, this dynamically imports LexicalPlaygroundEditorInternal (to avoid SSR issues). It also globally includes the Lexical playground CSS (index.css) and editor-specific styles (which likely style the toolbar, editor container, etc.). PostEditor simply renders the imported <LexicalPlaygroundEditorInternal> with initial content and onChange handler passed through.
    - **LexicalPlaygroundEditorInternal.tsx** ‚Äì (found in components/editor/). This is presumably the core editor component configured with the various Lexical plugins and nodes. It likely initializes a Lexical EditorState, adds the custom nodes (like mention autocomplete, table, list, etc.), and uses the plugins from the lexical-playground folder. Essentially, it‚Äôs the guts of the Lexical editor UI (the code from Lexical‚Äôs App component but integrated into our app context). We see it being imported in PostEditor. It presumably uses many of those playground components: for example, AutocompletePlugin, MarkdownPlugin, RichTextPlugin, HistoryPlugin, and custom toolbars for block formatting.
    - **EditorLayout.css, Toolbar.css, Menus.css** under components/editor/styles/ ‚Äì CSS for styling the editor UI, imported in PostEditor.
    - **Plugins & Nodes:** Files like AutocompleteNode.tsx, TablePlugin.tsx, MarkdownTransformers, etc., reside in lexical-playground and provide extended functionality (slash commands for inserting nodes, table editing UI, etc.). These are integrated via LexicalPlaygroundEditorInternal. For instance, the presence of a Plus (+) button plugin is referenced (we saw PlusButtonPlugin.tsx), likely to insert new blocks.
    - **Note:** The presence of lexical-playground/App.tsx and appSettings.ts suggests some code was copied wholesale. These specific files might not be used directly ‚Äì the actual mounting is done via PostEditor‚Äôs dynamic import. Thus, App.tsx in that folder could be unused (and a candidate for removal), as the app doesn‚Äôt navigate to a standalone playground page. All needed logic from it might have been refactored into LexicalPlaygroundEditorInternal.
    - **ReadOnlyLexicalViewerClient.tsx** (as mentioned in UI section) complements the editor by rendering saved Lexical JSON content outside the editor (for example, to show a post‚Äôs content to readers). If not used yet, it likely will be used when a post detail page or email sending is implemented.

  - **Editor Constants & Schemas:** There‚Äôs src/lib/editorConstants.ts providing EMPTY_LEXICAL_STATE (an empty editor JSON object) which is used to initialize new posts. Also src/lib/schemas/postSchemas.ts defines the Zod schema for post form values (title required, etc.) which is used by React Hook Form in the Post forms.

- **Chat Feature (Unreleased):**
  The codebase contains a **chat system scaffold** that is not currently exposed in the UI (the middleware reserves /chat route for authenticated users, but no page implementation is found). In src/lib/chat/ there are files like chat-service.ts, realtime-service.ts, and types.ts. These likely set up a real-time channel (maybe using Supabase Realtime or Y.js) for live chat or collaborative editing. There‚Äôs also a use-chat.ts hook. Since we don‚Äôt see any components using these (and no /chat page), this feature is probably **non-current (unused)**. It may have been planned for real-time chat or collaborative writing, but as of the main branch, none of the pages import lib/chat. Therefore, all files under src/lib/chat are candidates for removal unless development on chat resumes.

- **Miscellaneous:**

  - **useFollowerData.ts** ‚Äì A hook in src/lib/hooks/ (saw in search) to fetch follower information (perhaps used by profile or collective page to know if current user follows a target). It might not be used if the profile page does that check inline instead, so this could be unused.
  - **data/recommendations.ts** ‚Äì Contains the fetchRecommendations function and Recommendation type used by the Discover page. It makes a server-side call to the (possibly missing) recommendations API and handles errors. If the recommendations feature isn‚Äôt fully wired up (no API route or stub data), the Discover page might currently show an error alert or an empty list. This module is used by DiscoverPage and is thus part of the data flow, but the lack of an API implementation suggests it returns an error as coded (which is caught and shown to user).
  - **Stripe Utilities:** src/lib/stripe.ts exports getStripe(), which initializes the Stripe SDK using the secret key (service-side) or returns null if not configured. It‚Äôs used in subscriptionActions and the Stripe API routes. This centralizes Stripe setup so that the secret is never directly in API code (follows best practice of not re-initializing Stripe on every call).
  - **Supabase Utilities:** The app uses a dual Supabase strategy:

    - src/lib/supabase/server.ts ‚Äì Provides createServerSupabaseClient() for server-side use (it integrates with Next.js cookies/headers). All server components and actions call this to perform secure DB queries with the user‚Äôs session (the middleware and server components rely on it to get auth.getUser() etc.).
    - src/lib/supabase/browser.ts ‚Äì Provides createSupabaseBrowserClient() for client-side use (initialized with the public anon key). This is used in client components like ModernNavbar, PostCard, SubscribeButton, etc., to perform client calls (for example, supabase.auth.getUser() on the client to get the current user without an extra round-trip). It‚Äôs also used for client-side protected actions (e.g., in AuthForm to sign in, or in SubscribeButton to check user).
    - src/lib/supabaseAdmin.ts ‚Äì A special Supabase client initialized with the _service role_ key (from SUPABASE_SERVICE_ROLE_KEY). This bypasses Row Level Security. It‚Äôs used strictly on the server for admin tasks like inserting subscription records in webhooks or checking for existing user by email in invites. The code uses a Proxy trick to only init the client when actually used, and warns not to import it in client code (ensuring the secret key isn‚Äôt exposed).

  - **Database Types:** src/lib/database.types.ts ‚Äì This file (generated by Supabase) defines the TypeScript types for all tables, using a Database interface. It‚Äôs imported in many files to strongly type the data (e.g., Database['public']['Tables']['posts']['Row'] for a Post row). This ensures queries to Supabase can be typed. The code often narrows or extends these types (such as adding computed fields like like_count or joining relations).
  - **Zod Schemas:** in src/lib/schemas/. We saw references to postSchemas (for post form validation), collectiveSettingsSchema (for collective settings form), possibly collectiveInviteSchema or others. These define shape and validation for form inputs in server actions. For example, UserProfileSchema in userActions.ts uses Zod to validate full_name, username, bio, etc., before update. This pattern is used across update actions for consistent validation.

## File Relationships and Dependencies

The repository‚Äôs structure shows a clear layering of responsibilities:

- **Pages (src/app) vs Components:** Pages (server components) assemble data (often via Supabase queries or server actions) and pass it to React components for rendering. For example, the Profile page fetches profile info and posts, then renders ProfileFeed, passing in posts and using FollowButton/SubscribeButton components. The Discover page calls a lib function to get recommendations and then maps them to CollectiveCard components. By keeping data-fetching in the server layer and UI in components, it leverages Next.js‚Äôs RSC for performance.

- **Server Actions and API endpoints:** Many interactive operations are done via **Server Actions** rather than API routes, thanks to Next.js 13 capabilities. For instance:

  - Creating a collective: form calls createCollective (server action) directly.
  - Liking a post: PostCard calls togglePostLike (server action in likeActions.ts) from within a startTransition for optimistic update.
  - Updating profile or collective settings: forms would call updateUserProfile or updateCollectiveSettings server actions instead of hitting a REST endpoint.
    Server actions are found in **src/app/actions/** and are imported into components. They often use Supabase (server client) to perform DB changes and return a result object (success or error).

  Conversely, **API routes** are used where external services are involved or where client-side needs a secure transaction:

  - Stripe subscription creation (because it must keep secrets and redirect).
  - Stripe webhooks (called by Stripe, not by our front-end).
  - The GET list of collectives (could have been a server action too, but implemented as API likely to allow client-side fetching if needed or to decouple the data source).

  The code uses the **supabaseAdmin** client inside server actions or API routes when performing operations that require full DB privileges (e.g., writing to subscriptions or reading by email in the invites logic). Regular user-scoped queries use the standard supabase client which respects RLS.

- **Auth flows:** The Supabase integration means that on login/signup, a Supabase session cookie is set. The **middleware** reads this cookie via createServerClient to protect routes. The RootLayout also uses createServerSupabaseClient() to fetch the current session‚Äôs user on every page request and pass it to the navbar (so the nav can show correct links immediately). On the client, components like ModernNavbar and SubscribeButton call supabase.auth.getUser() to get immediate user context without waiting for a full page reload.

- **Inter-component dependencies:** Components are logically separated but do call into each other:

  - DashboardShell uses DashboardSidebar and SidebarNav internally. DashboardSidebar likely uses SidebarNav for the list of links (owner vs member collectives may be separate sections). StatsRow and RecentPostRow are used within the Dashboard page.
  - ProfileFeed uses PostCard, AudioSlider, ContentFilterTabs, and MicrothreadPanel. PostCard in turn uses the toggle like action.
  - CollectiveCard is used in at least two contexts: Discover (public) and perhaps within collective subscriber lists (if implemented). It‚Äôs imported from the dashboard path but used in a public page, illustrating code reuse across public/private boundary (it likely doesn‚Äôt contain privileged info, just display logic).
  - AuthForm is used by both SignIn and SignUp flows. The sign-in/up page components are thin wrappers around their client form components, which then use AuthForm for UI.
  - The SubscribeButton is a good example of dependency: it relies on /api/subscribe route and indirectly on the subscriptions table and Stripe config. It also depends on getSubscriptionStatus in subscriptionActions.ts for showing maybe a subscribed state (the profile/collective pages call getSubscriptionStatus on the server to decide if the current user is already subscribed and could pass that down to SubscribeButton, though in code we see profile page imports getSubscriptionStatus but may not fully implement a disable-state yet).
  - Invitation flow ties together: collectiveActions -> creates invite record, triggers email (likely via Supabase or external integration), and memberActions -> acceptCollectiveInvite uses the invite code to add the user to collective. The InviteMemberForm would call inviteUserToCollective (collectiveActions) and the invite page calls acceptCollectiveInvite (memberActions). These actions ensure a seamless handoff: one writes an invite with code, the other consumes it.

- **Unused/Legacy flags:**
  Based strictly on reference analysis in the code:

  - _Landing page section components:_ **NewspaperHero.tsx**, **DigitalPrintroom.tsx**, **NewsstandFooter.tsx** exist in the repo but are **not imported anywhere** (the landing page implemented those sections inline instead). They can be considered dead code in the current state.
  - _Legacy editor app files:_ **lexical-playground/App.tsx** and its **appSettings.ts** are likely leftover from the Lexical example and **never imported** in our app (our editor uses LexicalPlaygroundEditorInternal instead). These can be removed to tidy up.
  - _Chat-related files:_ **chat-service.ts, realtime-service.ts, use-chat.ts** are not referenced by any component ‚Äì since no /chat UI is live, these are **unused**. (The migrations and perhaps some database setup exist, but without UI they are dormant.)
  - _Profile/collective management:_ The **ManageMembersClientUI.tsx** and **InviteMemberForm.tsx** are not yet wired to a page (no import in any page component). Unless there is a hidden usage, these are currently not exposed ‚Äì effectively unused until the manage members page is completed. Similarly, **collectiveActions.inviteUserToCollective** and related invite handling are implemented but not triggered anywhere in the UI yet, aside from possibly manually via an admin console. They exist in code but the front-end link from ‚ÄúMembers‚Äù page is likely incomplete. If that page was forgotten to be committed, these would be waiting to be used. If not, they‚Äôre candidates for cleanup or completion.
  - _PostLikeButton.tsx:_ A standalone like button component (if it exists) is not used ‚Äì PostCard integrated that functionality itself. So this file can be removed as redundant.
  - _ReadOnlyLexicalViewerClient.tsx:_ Not used in the current UI (no page shows full post content yet). It‚Äôs not imported anywhere yet, so it‚Äôs unused **for now** ‚Äì likely to be used in a future feature (like viewing a post or in an email template generator).
  - _API/recommendations:_ The front-end expects it, but it doesn‚Äôt exist ‚Äì which is effectively a bug/unimplemented feature. Until it‚Äôs added, the Discover page‚Äôs fetchRecommendations will always throw an error and show the error Alert (meaning the Discover page is non-functional). This is an important catch: either an oversight or the API resides elsewhere (maybe an Edge Function, but not in code here). If truly missing, that call should be adjusted or the route implemented.

To summarize, **most of the code is well-referenced and integrated**, but a few sections appear to be in-progress or legacy. Files in this category (landing page section components, chat modules, unused UI components, incomplete routes) can be flagged as not currently used in the main branch. These would be the first candidates for removal or refactor, unless they are placeholders for imminent features. All flags above are purely due to no import/reference in the code ‚Äì for instance, removing them would not break any import statements in the app, confirming they‚Äôre not in use.
