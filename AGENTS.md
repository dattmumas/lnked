Implement Human-Readable URL Slugs
Objective: Improve URL friendliness by using slugs and usernames instead of database IDs in public-facing paths.
Summary: Replace opaque IDs in URLs with descriptive strings for users and posts. For user profiles, introduce a unique username handle and map profile pages to /@username (e.g. /@alice instead of /users/12345). This will require adding a username field to the user model if not present and ensuring uniqueness. The profile page route can be implemented by either a dynamic catch-all or via middleware rewrite: for example, detect @ in the path and rewrite to an internal profile page. Since the app currently uses /users/{id} for profile links
github.com
, we will update all references to point to the new /@username scheme. Similarly, for posts, add a slug field (perhaps generated from the title) to the posts table. Use this slug in the post URL, e.g. /posts/{postSlug} (or if posts belong to a collective or user context, possibly /collectives/[slug]/{postSlug} for clarity). Currently posts are accessed by ID (as seen in edit links like /posts/${post.id}/edit
github.com
), so we will refactor routes to use the slug. On the server, implement logic to look up the post by slug (and collective/user if needed) instead of ID. Ensure that slugs are unique within a context (e.g. unique per collective or globally unique, depending on design) and handle collisions by appending an identifier if necessary. These human-readable URLs will greatly improve UX and SEO. We will also remove or alias the old ID-based routes: e.g. keep an API or redirect from /posts/{id} to the slug URL so existing links aren’t immediately broken.
Key Files/Components: Database schema (add username to users, slug to posts if not already). Pages: create a new profile page handler for usernames (could be src/app/[username]/page.tsx or handled in middleware.ts since Next might treat @ as part of the name) – the implementation might use Next middleware to rewrite /@username -> /users/[userId] under the hood for simplicity. Update Navbar.tsx and any other components that link to user profiles or posts to use the new slug URLs (for example, the author link on post pages currently uses an ID
github.com
 – this will change to use @username). Update post page route to accept slug: e.g. src/app/posts/[postSlug]/page.tsx or nested under collective as appropriate, and fetch the post by slug. Remove old routes like src/app/posts/[postId] once new ones are in place (or leave them temporarily with a redirect).
Codex Best Practices: Implement this incrementally with careful version control. One commit could add the database fields and back-end support for slugs (including migration scripts and update in Supabase). Another commit can introduce the new routes and linking. Use descriptive PR titles like “feat: add username and slug support for friendly URLs”. Ensure atomic commits – for example, changing the profile URL in one go to avoid partially broken links in intermediate states. Write unit tests or integration tests for the slug resolution (e.g. given a username, the profile page returns correct data, given an invalid slug it 404s). Keep the code modular by writing helper functions (e.g. a lookup function to get user by username) rather than scattering slug logic everywhere. Finally, update documentation or code comments to reflect the new URL patterns for future contributors.
