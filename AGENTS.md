Implement Backend Handling for Profile Image Upload: On form submission, process the new avatar file in the server action (updateUserProfile in src/app/actions/userActions.ts). Since we added an avatar field in the form, we need to handle it in the server-side logic. Use Supabase Storage to store the image securely: create or use an existing storage bucket (e.g., avatars). In updateUserProfile, after validating other fields with Zod, handle the avatar file: e.g., if formData.avatar is present (you may get it as a File in a serverless context or perhaps as a base64 string if we chose that route), upload it to Supabase via the Admin client. You can use supabase.storage.from('avatars').upload('user-{id}/{filename}', fileBlob) to store it, generating a unique path for each user
github.com
github.com
. Once uploaded, get the public URL or storage path, and update the users.avatar_url column with that URL. Ensure the Supabase policy on the avatars bucket allows the user to upload or that you use the admin client for this operation. For example, generate a public URL via supabase.storage.from('avatars').getPublicUrl(...) if you want the image accessible publicly (or a signed URL if profiles/images should be protected by RLS). Then include avatar_url in the profileUpdate object that updates the users row
github.com
. Also consider resizing the image or enforcing a max size (to avoid huge uploads) – this can be done client-side or via a Cloud Function if needed, but at minimum, document the expectation. After saving the new avatar_url in the database, update UI: the user’s avatar should immediately reflect in the Navbar user menu (if it displays avatar) and profile page. We might call revalidatePath("/users/[userId]") or similar so the static profile page is refreshed
github.com
. Security: restrict the upload to the authenticated user (the server action already checks for user session
github.com
). By performing the upload in the server action, we keep the Supabase service role secure and avoid exposing storage write keys on the client. This backend step ensures profile media is properly stored and referenced, completing the avatar upload workflow without breaking existing profile updates.
