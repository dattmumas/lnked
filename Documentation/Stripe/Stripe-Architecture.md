# Stripe Integration and Subscription Feature Overview

## Stripe Setup and Configuration

The codebase uses the official Stripe Node.js SDK for server-side operations. A singleton Stripe client is initialized in **`src/lib/stripe.ts`**, reading the secret API key from environment variables. If `STRIPE_SECRET_KEY` is missing, the Stripe client will be undefined (gracefully handling cases where Stripe is not configured). On first use, it creates a new `Stripe` instance with a pinned API version (e.g. `'2025-05-28.basil'`) and TypeScript support enabled. This ensures consistent API behavior across updates and provides type definitions during development. All server-side Stripe calls (e.g. creating accounts, checkout sessions, etc.) go through this `getStripe()` helper to retrieve the configured Stripe client.

## Database Schema for Stripe Integration

Several database tables in Supabase are dedicated to the Stripe integration and subscription management:

- **Customers** – A mapping of our user IDs to Stripe Customer IDs. Each row in `public.customers` has an `id` (foreign key to a user) and a `stripe_customer_id` (the ID of the Stripe Customer object). This table tracks platform-level Stripe customers for subscribers.
- **Subscription Plans** – Represent subscription offerings (tiers) that creators can offer. The `public.subscription_plans` table includes an `owner_id` (the UUID of the creator, which can be a user or a collective) and `owner_type` (`'user'` or `'collective'`), the Stripe Price ID for the plan (`stripe_price_id`), and a JSON `price_snapshot` of the Stripe Price object. The snapshot stores price details (amount, currency, interval, etc.) for quick reference or offline display. A `benefits` JSON field may describe perks for the plan, and an `active` flag denotes if the plan is currently offered.
- **Subscriptions** – Records of active or past subscriptions. Each row in `public.subscriptions` tracks a subscriber (`user_id`), the target creator or collective they subscribed to (`target_entity_type` and `target_entity_id`), the Stripe Subscription status (e.g. 'active', 'trialing', 'canceled'), the Stripe Price ID of the subscribed plan, and period timestamps. These records are primarily updated via Stripe webhooks to reflect the latest status in Stripe.
- **Checkout Sessions** – Records of Stripe Checkout sessions initiated for subscriptions. The `public.checkout_sessions` table stores the Stripe Checkout Session ID (`stripe_session_id`), the subscriber user, the target entity (user or collective) being subscribed to, and a status (e.g. 'pending', 'completed'). This helps reconcile webhook events with initiated checkouts.
- **Users and Collectives** – The users table is extended with Stripe fields: `stripe_customer_id` (platform customer ID for the user), and for creators who connect Stripe: `stripe_account_id` (the Stripe Connect account ID, e.g. acct\_\*\*), `stripe_account_type` (Express/Standard), and boolean flags `stripe_charges_enabled` and `stripe_payouts_enabled` which indicate if their Stripe account can charge and payout (these get updated via webhook). Similarly, the collectives table has a `stripe_account_id` if a collective has its own connected Stripe account.

_(The `products` and `prices` tables used in earlier versions have been deprecated in favor of the leaner `subscription_plans` schema that stores Stripe Price IDs and snapshots.)_

## Creator Onboarding with Stripe Connect

Creators (either individual users or collective owners) must onboard to Stripe Connect (Express accounts) before they can receive subscription payments. The backend provides utilities to manage this:

- **Express Account Creation:** The helper `getOrCreateExpressAccount(userId)` (in **`src/services/stripe/userOnboarding.ts`**) checks if the user already has a Stripe Connect Account ID in the database, and if not, creates a new Express account via the Stripe API. It requests capabilities for card payments and transfers (payouts) and marks the account as belonging to our user (using metadata). The newly created Account ID is then saved to the `users` table (`stripe_account_id` field) for future use. This ensures idempotency – each user gets at most one connected account.

- **Onboarding Link Generation:** Once an Express account ID is available, the next step is to generate an onboarding link for the Stripe Connect onboarding flow. The function `createAccountLink(accountId, returnUrl)` uses Stripe’s Account Links API to create a one-time URL for onboarding. It specifies the account to be onboarded, the type of link (`account_onboarding`), and sets a refresh URL and return URL. In our implementation, the return URL is constructed to bring the user back to their settings page (with a query param `stripe=return` to indicate completion), and the same page is used as the refresh_url (or the base URL) so that if the user needs to restart the flow they can do so. For example, the code creates an account link and returns the `{ url }` to the client.

- **API Endpoint:** **`src/app/api/stripe-connect/route.ts`** is a Next.js API route that orchestrates the above steps. When the client (frontend) wants to start onboarding, it sends a POST request to `/api/stripe-connect`. The route ensures the user is authenticated, then calls `getOrCreateExpressAccount(user.id)` to get the Connect account ID. It then determines the appropriate base URL for redirects (using `NEXT_PUBLIC_SITE_URL` or the request origin) and calls `createAccountLink` with the account ID and a return URL pointing to the user's billing settings page. The API responds with the onboarding URL (or an error message).

On the **frontend**, the **ConnectStripePrompt** component triggers this flow. When the user clicks “Connect with Stripe,” it POSTs to `/api/stripe-connect` and on success, uses `router.push` to redirect the user to Stripe’s onboarding site. After the user completes onboarding on Stripe and is redirected back, the frontend uses a polling mechanism to check if the Stripe account is fully ready. Specifically, if the page loads with `?stripe=return`, the app will repeatedly GET `/api/self/stripe-flags` to fetch the latest `stripe_payouts_enabled` status. That `stripe-flags` endpoint (not shown here) returns the flags from the users table for the logged-in user; once `stripe_payouts_enabled` becomes true (meaning the user submitted all required info and Stripe activated the account), the frontend stops polling and refreshes the UI. This way, the app knows the creator’s Stripe account is now fully onboarded (i.e., charges and payouts are enabled) and can allow creating plans.

_For collective owners, a similar onboarding process was implemented in an earlier route (`/api/collectives/[slug]/stripe-onboard`). In the latest design, collective Stripe onboarding would be handled in a unified way (potentially using the same `/api/stripe-connect` but specifying the context). The collectives table stores a separate `stripe_account_id` for each collective, and webhook events (Stripe account updates) update collective flags just like user flags. In either case, a creator must finish this onboarding before they can create subscription plans._

## Creating Subscription Plans (Pricing Tiers)

Once a creator has a Stripe Connect account ready, they can create subscription plans (pricing tiers) that subscribers can purchase. There are two contexts for plans: personal plans for individual users, and collective plans for group collectives. The implementation for both is analogous – it ultimately creates a Stripe Price and records it in our `subscription_plans` table.

**For individual users (personal plans):** The server action `createPersonalSubscriptionPlan` (in **`src/app/stripe-actions/subscription-plans.ts`**) handles creating a new plan for the authenticated user. Key steps in this workflow:

1. **Authentication and Stripe Account Check:** The action verifies the user is logged in, then checks that the user’s Stripe Connect account is ready for payouts. It fetches `stripe_account_id`, `stripe_charges_enabled`, and `stripe_payouts_enabled` from the `users` table for the current user. If the account isn’t fully enabled, the action returns an error prompting the user to finish onboarding. This prevents creating plans that cannot be used.

2. **Stripe Initialization:** It obtains the Stripe client via `getStripe()` and then ensures the user has an Express account. As a safeguard, `getOrCreateExpressAccount(user.id)` is called here as well (in practice, the user should have one by this point). This returns the connected Stripe Account ID (`connectedAccountId`).

3. **Creating Product and Price in Stripe:** Using the connected account context, the code first creates a Product on Stripe to represent the subscription plan. The product’s name is the plan name provided by the user (and could be something like "Premium Plan"). Then it creates a recurring Price under that product, with the specified monthly cost. This Price is created in the **connected account’s scope** by passing `{ stripeAccount: connectedAccountId }` to the Stripe API calls. The price parameters include currency (e.g. USD), the amount (converted to cents), and a monthly recurring interval. By creating the Price in the creator’s connected Stripe account, payments for this plan will go directly to the creator (with our platform able to take a fee via Stripe Connect if configured).

4. **Persisting the Plan:** After a successful creation, the new plan is saved in our database. The code inserts a row into `subscription_plans` with `owner_type: 'user'`, the `owner_id` as the user’s ID, the `stripe_price_id` of the new Stripe Price, and stores the entire Stripe Price object as a JSON `price_snapshot`. It also stores any benefits description (if provided) and marks the plan as `active: true`. The insert returns the new plan’s ID, which the action includes in the response to the frontend. This database record links our internal representation of the plan with the Stripe price that users will subscribe to.

**For collectives (group plans):** The flow is similar but initiated via an API route. The **`POST /api/collectives/[slug]/plans`** endpoint (see **`src/app/api/collectives/[slug]/plans/route.ts`**) allows a collective admin to create a subscription plan for a collective. The steps are:

1. **Authentication and Authorization:** The route uses the collective slug to look up the collective ID, then ensures the request user is an admin or owner of that collective (using `validateCollectiveAccess` logic). Only authorized users can create plans for the collective.

2. **Stripe Account Determination:** In the current implementation, it checks the _user’s_ Stripe account (`stripe_account_id` in the users table) as the account to use for creating the price. (This suggests that at this point, the collective might be using the owner's Stripe account. In a fully separate collective scenario, one would use the collective’s own `stripe_account_id` – the code may evolve to do that. But as of now, if the user themselves hasn’t onboarded to Stripe, it returns "Creator not onboarded to Stripe".)

3. **Create Price on Stripe:** Instead of a two-step product then price creation, this route uses Stripe’s ability to create a Price with embedded product data. It calls `stripe.prices.create` on the connected account (using the `stripeAccountId` from above) to create a new recurring price. The request includes `unit_amount`, `currency`, and `interval` (month or year) as provided by the client, and also a `product_data` object with the plan name and optional description. This creates both a Product (with the given name/description) and a Price in one API call, simplifying the logic. The Stripe Price’s metadata is tagged with the collectiveId as well.

4. **Persist in Database:** Similar to personal plans, the new collective plan is saved in `subscription_plans`. The route inserts a row with `owner_type: 'collective'`, `owner_id` as the collective’s ID, and also `collective_id` (for clarity, it duplicates owner_id here). The Stripe Price ID and a JSON snapshot of the price are stored, and `active: true`. (No specific benefits JSON is handled in this route, it sets `benefits: null` in the example shown.) If the insert fails, it returns an error; otherwise, the plan is successfully created.

After a plan is created, the frontend will typically fetch and display it. Rather than storing plan names or prices in our own schema, the application reads directly from Stripe whenever possible to ensure the latest info. A utility in **`src/lib/stripe/plan-reader.ts`** (`fetchPlansForOwner`) is responsible for retrieving all active plans for a given owner (user or collective) from the database and hydrating them with live Stripe data. It queries `subscription_plans` for that owner and uses the Stripe SDK to retrieve each corresponding Price by ID. If Stripe returns an error (e.g. the price was deleted), it falls back to the stored `price_snapshot`. The result is a list of resolved plans including the Stripe Price details (amount, currency, interval, and the nested Product name) which the frontend can then use to display plan options to users.

## Subscription Checkout Flow

Once subscription plans exist, end users can subscribe to them. This is facilitated by the **`POST /api/subscribe`** endpoint (implemented in **`src/app/api/subscribe/route.ts`**). This is one of the central pieces of the Stripe integration, handling subscription checkout in a secure manner. The flow includes robust validation, idempotency safeguards, and branching logic depending on whether the user already has a default payment method on file. Below is an outline of what happens when a user attempts to subscribe:

1. **Input Validation and Rate Limiting:** The route expects a JSON body with `priceId` (the Stripe Price ID of the plan to subscribe to), `targetEntityType` (`'user'` or `'collective'` – who is being subscribed to), `targetEntityId` (the creator’s ID or collective ID), and an optional `redirectPath` for post-checkout navigation. It first ensures the request is authenticated (there is a logged-in user). It also enforces a simple rate-limit (using an in-memory or `api_cache` mechanism) to prevent abuse – if too many subscription attempts occur in a short time, it returns a 429 error. If the request data doesn’t pass Zod schema validation (e.g. missing or malformed fields), it returns a 400 with error details.

2. **Idempotency Check:** Before proceeding to create any Stripe sessions, the handler checks for a duplicate subscription attempt. It uses a combination of the userId and target entity to detect if a subscription is already in progress. This is done via a custom `checkIdempotency` function (not shown in snippet) which likely uses the `api_cache` table. If a duplicate is found, it immediately returns the previously generated checkout URL to avoid creating another session. This prevents double-charging if a user accidentally clicks subscribe twice.

3. **Lookup Plan and Connected Account:** The handler then looks up the subscription plan details from our database. It finds the row in `subscription_plans` matching the provided `priceId` (and that is active). This gives us the plan’s owner. The code then determines the Stripe connected account that should receive the funds. If the plan’s `owner_type` is `'user'`, it will fetch that user’s `stripe_account_id` from our database. If the user’s account is not found or not ready, it returns an error like "Creator is not ready to accept payments". For now, the code does not yet support `'collective'` owner types in this route (it immediately responds with a 400 "Collective subscriptions not yet supported" if encountered). In the `'user'` case, once it has the creator’s Stripe Account ID, it saves it as `connectedAccountId` for use in the next steps.

4. **Ensure Price in Platform Account:** A subtle complexity arises if the Price was created under a connected account. The code includes a helper `ensurePlatformPrice(priceId, connectedAccountId, planName)` that tries to ensure the Stripe Price ID is accessible from our platform’s Stripe account. In practice, when we create Prices in a connected account, we **cannot directly subscribe a customer from our platform account** to a connected account’s price without cooperation. The solution implemented is: attempt to retrieve the Price with our platform’s key – if it fails (resource missing), the code will retrieve the Price from the connected account and then clone it into the platform Stripe account. It does so by creating a new product in the platform account (copying the name from the connected account’s product) and then creating a new price in the platform account with the same amount/currency/interval. It updates our database (`subscription_plans`) to replace the Stripe Price ID with the new platform price ID. This ensures going forward, subscribers will use the platform’s price. (This approach was chosen to simplify using Checkout and managing subscriptions from the platform side, at the cost of an extra Stripe object.) After this step, whether originally or via cloning, we have a `platformPriceId` that the platform (our Stripe API key) can work with.

5. **Authorization for Collective (if applicable):** If the target entity type is `'collective'` (meaning the user is trying to subscribe to a collective’s plan), the route calls `checkCollectiveAuthorization` to ensure the subscriber should be allowed (for example, maybe a collective could have invite-only subscriptions). If that check fails, it returns 401 Unauthorized. In most cases, this is likely a no-op (everyone is allowed to subscribe), but the hook is there for business rules.

6. **Stripe Customer Setup:** Next, the subscriber’s Stripe Customer object is prepared. The code uses `getOrCreateStripeCustomer` to either fetch an existing platform Customer ID for the user or create a new one. This function checks our `customers` table and, if a Stripe customer ID is found, verifies it still exists on Stripe (it may call `stripe.customers.retrieve()` and handle a "resource missing" by treating it as stale). If no valid customer exists, it creates a new Customer on Stripe with the user’s email and some metadata, then upserts it into our `customers` table and also updates the `users.stripe_customer_id` for convenience. The result is a `customerId` for the subscriber on our platform Stripe account. (Remember, this customer is always on the _platform_ Stripe account, which holds the payment methods.)

7. **Default Payment Method Check:** After obtaining the Stripe customer, the route checks if the user already has a saved default payment method. It calls `fetchDefaultPaymentMethod(customerId)` (imported from **`customer-utils.ts`**), which likely uses Stripe’s API to get the customer’s default payment method (perhaps via `stripe.customers.retrieve()` and checking `invoice_settings.default_payment_method`). If a default payment method exists, `hasDefaultPM` is true. This branching is crucial: if the user has a card on file, we can **skip the Stripe Checkout flow** and directly create the subscription via API for a one-click subscribe; if not, we’ll create a Checkout Session to collect payment details.

8. **Success and Cancel URLs:** The code computes the URLs for redirection after checkout. It takes the provided `redirectPath` (defaulted to "/") and ensures it’s a safe relative path, then prepends our site base URL to form full URLs. The `success_url` is set with a special query param `stripe_session_id={CHECKOUT_SESSION_ID}` so we can identify the session on return. The `cancel_url` is typically just the page the user was on (so they can retry or go back).

9. **Branch A – No Saved Card (Checkout Session):** If the user does _not_ have a default payment method (`!hasDefaultPM`), the route will create a Stripe **Checkout Session** for the subscription. It prepares the parameters for `stripe.checkout.sessions.create`: it includes the customer ID, sets `mode: 'subscription'`, and defines a single line item for the subscription price (quantity 1). It also sets `payment_method_collection: 'if_required'`, which means Stripe will prompt for payment only if the customer doesn’t already have one on file (in our case, they don’t). The `subscription_data` field is used to pass metadata into the subscription that Stripe will create – the code attaches metadata like `userId` (subscriber), `targetEntityType` and `targetEntityId`, and a marker `createdVia: 'api_v2'`. It also includes `transfer_data: { destination: connectedAccountId }` in `subscription_data`. This last part is critical: it tells Stripe that for each invoice payment of this subscription, the funds (minus Stripe fees and any platform application fee) should be transferred to the connected account (the creator). In essence, this is how the revenue goes to the creator’s Stripe account. The session is also configured to collect billing address and automatically update the customer’s default payment method on completion. Tax collection is toggled on if `STRIPE_AUTOMATIC_TAX_ENABLED` is true.

   The server creates the Checkout Session with these parameters and an idempotency key (to avoid duplicate sessions on repeated requests). Stripe returns a URL for the hosted checkout page. The code verifies that a URL was returned (just in case). It then performs two record-keeping tasks: it inserts a row into `checkout_sessions` table with the session ID, user, target entity, and status 'pending', and it stores an idempotency record in `api_cache` to mark that a subscription attempt is in progress for this user & plan. Finally, it logs the creation and returns `{ url: checkoutSession.url }` to the client. The frontend will receive this and redirect the user to the Stripe Checkout page.

10. **Branch B – Default Card on File:** If the user already has a default payment method (`hasDefaultPM` is true), the flow becomes more streamlined: the server can create a Subscription directly via API without user interaction. The code prepares an idempotency key `subscribe_<userId>_<platformPriceId>` for safety. Then it calls `stripe.subscriptions.create` using our platform Stripe account, with the customer ID and the price (now using the platform Price ID we ensured earlier). It sets `payment_behavior: 'error_if_incomplete'` to ensure it errors if the payment cannot be charged (instead of creating an incomplete subscription). It also passes `transfer_data: { destination: connectedAccountId }` here as well, so that payments will go to the creator’s account. Metadata (userId, targetEntityType, targetEntityId) is attached to the subscription for bookkeeping. If this call is successful, Stripe immediately creates the Subscription and attempts payment on the default card. The route logs this action and returns a response containing the new `subscriptionId`. (The initial payment might be in progress; we rely on webhooks to update the DB status, but from the client perspective, the subscription is active.)

11. **Response to Client:** As noted, the API returns either `{ url: "https://checkout.stripe.com/..." }` or `{ subscriptionId: "sub_12345" }`, or an error. The client-side logic uses this to proceed. For example, the `SubscribeButton` component in the frontend checks the response: if a URL is present, it redirects the browser to it; if a subscriptionId is returned, it means the subscription was created instantly, so it shows a success message and refreshes the state.

In summary, the `/api/subscribe` route encapsulates the entire subscribe workflow – validating the request, ensuring the creator and subscriber are set up in Stripe, then either handing off to Stripe-hosted Checkout for new payment info or doing a one-click server-side subscription if possible. This design provides a seamless UX (one-click subscribe for returning users) while still covering the case where a user has no card on file.

## Stripe Webhook Processing

After a subscription checkout or any subscription lifecycle event, Stripe sends webhook events to our application. The endpoint **`POST /api/stripe-webhook`** (implemented in **`src/app/api/stripe-webhook/route.ts`**) handles these events securely and updates our database accordingly. Here’s how it works and the key events it processes:

- **Security and Verification:** The webhook route first obtains the raw request body and the Stripe signature header, and it checks for the configured `STRIPE_WEBHOOK_SECRET` in our environment. It uses a custom parser to parse the signature header and validate the timestamp (to mitigate replay attacks). If the signature or secret is missing or the timestamp is too old, it logs an error and returns 400 Bad Request. Then it calls `stripe.webhooks.constructEvent(rawBody, sig, webhookSecret)` to verify the signature and construct the Stripe.Event object. If this throws (signature mismatch), a 400 response is returned and the error is logged. Only if this succeeds do we proceed to handle the event.

- **Idempotency for Webhooks:** Stripe may retry events, and we also want to avoid processing the same event twice if our logic causes duplicate triggers. The code uses an `api_cache` table as an idempotent log for webhook events. It defines a helper `processWebhookEvent(eventId, eventType, timer)` that checks the `api_cache` for a key `webhook_event:<eventId>`. If found, it logs that the event was already processed and returns a flag so we can skip handling it again. If not found, it inserts a record into `api_cache` to mark this event as processed. This ensures even if Stripe retries the same event (or our server re-receives it), we don’t duplicate work like double-inserting a record.

- **Relevant Events:** The webhook handler is primarily concerned with a set of events defined in `relevantEvents`: these include `checkout.session.completed`, `customer.subscription.created`, `customer.subscription.updated`, `customer.subscription.deleted`, and `account.updated`. It will ignore other event types (responding with a generic OK) to avoid unnecessary processing for events we don’t need.

- **Handling `checkout.session.completed`:** This event fires when a Stripe Checkout Session (for a subscription) is successfully completed by the user. In our flow, this indicates the user added their payment method and the subscription has been created. The code checks that the session’s mode was subscription and that it has `customer`, `subscription`, and `metadata` fields – all of which we set when creating the session. The metadata should include our `userId`, `targetEntityType`, and `targetEntityId` for the subscription (because we passed those in subscription_data). Once validated, the handler performs two main actions:

  1. **Upsert Customer Record:** It extracts the Stripe Customer ID from the session and calls `upsertCustomerSafely(validatedMetadata.userId, stripeCustomerId)`. This will ensure our `customers` table has a record linking the user to that Stripe Customer ID (in case it wasn’t already created earlier). The upsert function is idempotent and uses `onConflict: 'id'` so it will insert or update the row for the user. If this fails, it logs an error and returns a 500 to tell Stripe to retry (since failing to link the customer could cause issues for future charges).

  2. **Record Checkout Session:** It then inserts a row into our `checkout_sessions` table to mark this session as completed. The code upserts (insert with onConflict) a record with the session ID, the user ID (from metadata), the target entity type and ID, status `'completed'`, the Stripe Subscription ID that was created, and a timestamp. This is useful for bookkeeping: we now know that checkout session `X` resulted in subscription `Y` for user Z. (We use upsert here in case the same session event comes again – we’d just update or ignore if it’s duplicate.)

  After these, it logs success and continues. Notably, we do **not** directly insert into our `subscriptions` table here – instead, we wait for the subscription events below to handle that. The rationale is that after checkout completes, Stripe will send a `customer.subscription.created` event almost immediately. That event will carry the full subscription details we need to populate our subscriptions table.

- **Handling subscription events (`customer.subscription.created/updated/deleted`):** These events inform us of changes to a user’s subscription. The code handles created/updated/deleted in one combined block since the logic is similar for all. When such an event arrives, we first validate that the subscription object contains the expected metadata (which we attached on creation). If the `subscriptionObject.metadata` is missing, that’s an error – our system wouldn’t know which user or entity this subscription is for, so it logs and returns 400. Assuming the metadata is present, it parses it with Zod schema to get the `userId`, `targetEntityType`, and `targetEntityId`.

  Next, it determines the Stripe Price ID and quantity. Stripe includes an array of items for the subscription; our design uses exactly one price per subscription, so we take the first item. The code grabs `priceItem = subscriptionObject.items.data[0]` and from it extracts the `stripePriceId` (either directly or via `price.id`). It then constructs a **SubscriptionUpdateData** object with all the fields we want to store/update in our `subscriptions` table. This includes: the subscription’s ID (as our primary key), the subscriber’s user_id, the status (`subscriptionObject.status`), the Stripe price ID, the target entity type & id, the quantity, whether cancel_at_period_end is set, the start and end of the current period, trial start/end if any, and so forth. It converts Unix timestamps to ISO date strings for storage. It also carries over the raw `subscriptionObject.metadata` (which might include additional info) and sets an `updated_at` timestamp (current time).

  To write this into the database, the handler uses an optimized helper `updateSubscriptionSelectively(subscriptionId, newData)`. This function (defined in the same file) will check the current row in the `subscriptions` table and compare each field, updating only those that changed. If the subscription row doesn’t exist yet (e.g. on a `created` event), it will insert a new record via `upsert`. This selective update approach avoids overwriting fields unnecessarily and ensures, for instance, that on an update event we only change what’s needed (like status or period_end) while preserving other fields. The webhook handler calls this and examines the result. If there was a database error during upsert/update, it logs the failure and returns a 500 so Stripe will retry the webhook. Otherwise, on success, it logs that the subscription was processed.

  In essence, whenever a user starts a subscription or their subscription renews, is updated, or gets canceled, these webhook handlers create or update the row in our `subscriptions` table to mirror Stripe’s state. For example, on `customer.subscription.deleted`, the status in Stripe might become `canceled` or `ended` and our DB will reflect that. On `updated`, fields like `current_period_end` or `cancel_at_period_end` might change, which our code will update.

- **Handling `account.updated`:** This event is sent when a connected Stripe account’s details change (for instance, when a creator finishes onboarding, or if Stripe updates the account’s capabilities). The webhook route listens for `account.updated` specifically to catch when a creator’s `charges_enabled` or `payouts_enabled` flags become true. The handler will take the Stripe Account object from the event, find which collective or user it corresponds to in our DB, and update the flags accordingly. In the current code, it only handles collectives: it searches the `collectives` table for a row with `stripe_account_id == event.data.object.id` and updates that collective’s boolean fields for `stripe_charges_enabled`, `stripe_payouts_enabled`, etc.. If the update fails, it logs an error. If successful or not, it simply breaks (no response needed beyond the generic acknowledgment at the end). _(For user accounts, presumably similar logic could update the users table, though the code shown updates collectives. Possibly the `self/stripe-flags` API handles user flags by reading directly from Stripe on demand or via a separate route.)_

- **Unhandled events:** If a Stripe event arrives that is not in our relevant set, the code will log a warning and ignore it. Finally, if all processing goes well (or the event is not relevant), the handler returns a JSON `{ received: true }` with HTTP 200 to acknowledge receipt. Stripe will then consider the webhook delivered.

In summary, the webhook processor ensures our system stays in sync with Stripe. It creates customer records when checkout sessions complete, updates subscription records when statuses change, and updates connected account status flags. Importantly, it uses secure verification and idempotency to handle retries gracefully. All errors are logged with contextual info (using a `webhookLogger`) so that issues can be debugged if a webhook fails.

## Subscription Management and Billing

Once subscribed, users may need to manage their subscriptions and payment methods. The codebase includes features for checking subscription status, allowing users to cancel subscriptions, and managing billing (payment methods, billing portal).

- **Checking Subscription Status:** A lightweight GET endpoint `/api/subscription-status` is implemented (not shown above, but referenced in the frontend) to let a user know if they are currently subscribed to a particular creator. The front-end uses this to decide whether to show a “Subscribe” button or a “Manage Subscription” option. Internally, this likely queries the `subscriptions` table for an active subscription by the current user to the target entity. Indeed, there is a server function `getSubscriptionStatus(targetType, targetId)` that does exactly that: it checks if an active subscription exists in the DB for the logged-in user to that target. If found, it returns details like the status and subscription ID; otherwise it reports not subscribed. This allows the UI to immediately reflect subscription state without always calling Stripe.

- **Unsubscribing (Cancelling Subscription):** To let users cancel, the code provides an action `unsubscribeFromEntity(dbSubscriptionId, stripeSubscriptionId)` in **`src/app/actions/subscriptionActions.ts`**. When invoked, it first ensures the request is authenticated and that the subscription in question belongs to the current user (it fetches the subscription row and verifies the `user_id`). If not, it returns a permission error. If yes, it proceeds to cancel the Stripe subscription. Rather than immediately deleting, it uses a safer approach: it sets the subscription to cancel at period end. The code calls `stripe.subscriptions.update(stripeSubscriptionId, { cancel_at_period_end: true })` using the Stripe SDK. This schedules the cancellation, so the user will retain access for the remainder of the paid period. The method returns the updated Stripe Subscription object, which the code can log (especially in development, it logs the subscription ID that’s set to cancel). The comment in code notes an alternative (`subscriptions.del`) was considered for immediate cancellation, but the chosen approach is more user-friendly. After scheduling the cancellation on Stripe, the action doesn’t directly update our database. Instead, it relies on Stripe to send a `customer.subscription.updated` or `...deleted` webhook when the cancellation is effective, which our webhook handler will then reflect in the `subscriptions` table. This avoids any race conditions or mismatches. The action may trigger a revalidation of relevant pages (e.g. refresh the user’s dashboard). Finally, it returns a success message indicating the subscription will end at period’s end. From the user’s perspective, after clicking “Cancel” they might immediately see in the UI that their subscription is scheduled to cancel (the UI can read the updated `cancel_at_period_end` flag via subscription status). If needed, they could also resume it (Stripe supports that) before the period ends, but that’s beyond our scope here.

- **Stripe Billing Portal:** Stripe provides a hosted billing portal for customers to manage payment methods, view invoices, and cancel subscriptions. In our app, there is a **Manage Billing** button (see **`ManageBillingButton.tsx`**) which, when clicked, calls a POST to `/api/billing-portal`. The expectation is that this API route creates a Billing Portal Session via Stripe’s API. Although the route code isn’t shown, it likely uses `stripe.billingPortal.sessions.create({ customer: <stripeCustomerId>, return_url: <...> })` and returns the portal URL. The client then `router.push`es to that URL. This gives users an alternative interface (hosted by Stripe) to manage their subscription – for example, updating card details or downloading receipts – especially useful for handling things like updating an annual subscription’s card on file, etc. Our Manage Billing button is enabled regardless of subscription status; if the user isn’t subscribed to anything, the portal would just show no active subscriptions but still allow card management. We set `return_url` to our app (likely the billing settings page), so when the user exits the portal they come back to our interface.

- **Payment Methods Management:** The application includes a custom UI for managing saved payment methods as well. This is the section under user settings (personal billing settings) where a user can add or remove credit cards. Under the hood, this uses Stripe Setup Intents and the PaymentMethods API:

  - _Adding a Card:_ In the **AddCardDialog** component, the app integrates Stripe Elements on the client side to collect card details. When the dialog opens, the client requests our server to create a SetupIntent by calling the server action `createSetupIntent()`. This action (in **`stripe-actions/billing.ts`**) creates a Stripe SetupIntent on the platform account for the user’s customer ID. If the user doesn’t already have a Stripe customer, it will create one at this point (it checks `stripe_customer_id` in the users or customers table and creates a new customer if needed, similar to the subscribe flow). The SetupIntent’s client secret is returned to the frontend. The frontend then initializes Stripe Elements with that client secret, and when the user submits their card, it calls `stripe.confirmCardSetup(clientSecret, { payment_method: {card: <CardElement> } })` via the Stripe.js library. This securely vaults the card details with Stripe and attaches the card as a PaymentMethod to the customer. If this succeeds (`setupIntent.status === 'succeeded'`), we next mark it as the default payment method:

    After a successful SetupIntent, the client calls our `setDefaultPaymentMethod(paymentMethodId)` server action. The parameter `paymentMethodId` is obtained from the SetupIntent result (`setupIntent.payment_method`). The `setDefaultPaymentMethod` action will attach the payment method to the Stripe customer (if not already attached) and update the customer’s default payment method to this ID. Specifically, it uses `stripe.paymentMethods.attach(pmId, {customer})` and then `stripe.customers.update(customerId, { invoice_settings: {default_payment_method: pmId} })`. Our backend knows the `customerId` because it looks it up from the `customers` table using the user’s ID. Once this action returns success, the frontend knows the card was saved. We show a toast confirmation and refresh the payment method list. The new card will now be used for future subscriptions and renewals by default. (If the user had multiple cards, this action effectively sets the latest one as the default; we don’t currently provide a UI for choosing among multiple saved cards except by deleting others.)

  - _Listing Saved Cards:_ The **PaymentMethodsClient** component (in the billing settings page) displays the user’s saved payment methods. It likely gets a list of PaymentMethod info from the page’s server component. Our backend can retrieve the customer’s saved payment methods via Stripe’s API (`stripe.paymentMethods.list` for the customer). For example, the server might do `stripe.paymentMethods.list({ customer: customerId, type: 'card' })` to get all card-type payment methods. It then serializes the needed info (last4, brand, exp date, and whether it’s the default). The `PaymentMethodsClient` receives an array of `methods` props (see the interface with `id, brand, last4, exp_month, exp_year, isDefault`). It renders each card with the last four digits and expiration. The default card is labeled with a "Default" badge.

  - _Removing a Card:_ Next to each non-default card in the list, there is a delete (“✕”) button. When clicked, it dynamically imports the `deletePaymentMethod` action and calls it with the PaymentMethod’s ID. The `deletePaymentMethod(paymentMethodId)` action (also in **`stripe-actions/billing.ts`**) will detach the card from Stripe and remove it from the customer. It first checks that the PaymentMethod actually belongs to the current user’s Stripe customer (to avoid any malicious attempt to remove someone else’s card): it retrieves the PaymentMethod from Stripe and compares its `customer` field to our customer ID. If it matches, it calls `stripe.paymentMethods.detach(paymentMethodId)` to remove it. If that succeeds, it returns success. On the frontend, upon success, we simply refresh the list (using `router.refresh()`) to reflect that the card is gone. Note that if the removed card was the default (though our UI doesn’t show a delete for the default), Stripe would automatically unset default or pick another – but we intentionally only allow deleting non-default in the UI to avoid ambiguity.

These billing features ensure the user can manage how they pay for subscriptions. Having a default payment method saved enables the one-click subscribe flow described earlier. Users can add multiple cards (though our UI doesn’t explicitly list more than one default, Stripe can hold multiple and just mark one as default). If a user wants to change their card for a subscription, they can either add a new card (which becomes default for future charges) or use the Stripe billing portal for more advanced management like seeing past invoices.

- **Account Deletion Cleanup:** One last aspect worth noting is that if a user deletes their account from our platform, we attempt to clean up their Stripe data. In **`userActions.ts`**, the `deleteUserAccount` flow calls a helper `cleanupExternalServices(user.id)` which will remove any external links for that user. For Stripe, it checks if the user had a `stripe_customer_id` and if so, calls `stripe.customers.del(stripe_customer_id)` to delete the customer on Stripe. This would delete all their saved payment methods and subscriptions on Stripe’s side as well. This cleanup is done in a try/catch and logged, but even if it fails, the account deletion proceeds (we don’t block user deletion on it). Additionally, the code also deletes the user’s auth record from Supabase and any related data. So we attempt to be good citizens and remove identifiable Stripe data when a user opts out of the platform.

## Recent Enhancements (2025-06)

The integration has been expanded with several production-grade features:

### 1. Dunning & Grace-Period Handling

- Webhook now listens for `invoice.payment_failed` / `invoice.payment_succeeded` and updates `subscriptions.status` to `past_due` / `active` accordingly.
- On first failure it sets `subscriptions.grace_period_expires_at` to **now + 7 days** giving subscribers time to fix payment.
- A scheduled Postgres function `cancel_expired_grace_subscriptions()` (invoked hourly via `pg_cron`) auto-cancels subscriptions whose grace window has elapsed.
- Users receive an in-app notification (and future email) immediately when a payment fails.

### 2. Refund & Chargeback Support

- Webhook handles `charge.refunded` and `charge.dispute.funds_withdrawn`.
- The associated subscription is marked `canceled` and future entitlements can be revoked.

### 3. Multiple Payment Methods + Wallets

- `payment_method.attached` webhook automatically sets a newly added card as the customer’s default and retries the latest open invoice.
- Apple Pay and Google Pay are enabled via Stripe Checkout (automatic payment methods) and a new `PaymentRequestButton` component for on-site wallet payments.

### 4. Trials & Coupons

- `/api/subscribe` accepts optional `trialDays` (1-31) and `coupon` fields, validating coupons via `stripe.coupons.retrieve`.
- Frontend `SubscribeButton` dialog now includes an optional coupon code input.

### 5. Plan Lifecycle Management

- Server actions `deactivatePersonalSubscriptionPlan` / `reactivatePersonalSubscriptionPlan` allow creators to toggle plan availability; UI buttons added in **PersonalSubscriptionPlansClient**.

### 6. Accounting Ledger & Dashboard Upgrade _(2025-07 refresh)_

The legacy `creator_earnings` table has been **deprecated** in favor of a fully normalised accounting ledger:

- **`accounting.accounts`** – one row per money-holding entity (creator, collective, platform) with running `current_balance_cents`.
- **`accounting.ledger_entries`** – immutable append-only money movements (signed `amount_cents`).

Stripe webhook now dual-writes:

| Event                                                | Creator Entry | Platform Entry |
| ---------------------------------------------------- | ------------- | -------------- |
| `invoice.payment_succeeded`                          | `+net`        | `+fee`         |
| `charge.refunded` / `charge.dispute.funds_withdrawn` | `−net`        | `−fee`         |

Aggregations are surfaced through materialised views:

- `accounting.v_monthly_creator_earnings` – monthly `gross_cents`, `net_cents` per creator.
- `accounting.v_creator_totals` – lifetime & current balances.

The **Creator Dashboard** (`/dashboard`) and **`GET /api/creator/earnings`** now read exclusively from these views, guaranteeing consistency with ledger balances. A feature flag `LEDGER_DUAL_WRITE` controls migration phases:

- `true` – write ledger **and** legacy table (staging)
- `only` – write **ledger only**, UI fully migrated (production target)

Wallet setup docs remain in `Documentation/Stripe/Wallets-Setup.md`.

### 6.1 Ledger Automation Additions _(2025-07)_

Recent backend ops improvements ensure ledger consistency and observability:

| Item                          | Path                                                   | Notes                                                                |
| ----------------------------- | ------------------------------------------------------ | -------------------------------------------------------------------- |
| **Ledger mapper utility**     | `src/lib/ledger/stripe-event-mapper.ts`                | Maps Stripe events → `LedgerInsert[]`, eliminating duplicated logic. |
| **Ledger service wrapper**    | `src/lib/ledger/ledger-service.ts`                     | Handles insert + telemetry + flag gating; called by webhook.         |
| **Hourly view refresh**       | `pg_cron` migration `refresh_monthly_creator_earnings` | Keeps `accounting.v_monthly_creator_earnings` fresh for dashboards.  |
| **Balance sanity Jest tests** | `__tests__/ledger/balanceSanity.test.ts`               | Verifies net-zero after refund/chargeback sequences.                 |
| **GitHub Actions workflow**   | `.github/workflows/ledger-tests.yml`                   | Runs migrations & ledger test suite on every push / PR.              |

These augment the Accounting Ledger & Dashboard Upgrade section, providing continuous correctness checks and near-real-time analytics.

### 7. Tax Compliance

- Checkout sessions and direct subscriptions set `automatic_tax.enabled` based on `STRIPE_AUTOMATIC_TAX_ENABLED` env.
- Optional `tax_id_collection.enabled` gate via `STRIPE_TAX_ID_COLLECTION_ENABLED`.

These upgrades complete the 2025-Q2 payments roadmap and bring the integration to parity with production standards for subscription platforms.

## Conclusion

In summary, the Stripe integration in this codebase is comprehensive and follows best practices for security and maintainability. It covers creator onboarding to Stripe Connect (with express accounts and transfer payouts), plan creation and storage, a dynamic checkout flow that optimizes for returning users, robust webhook handling to keep the database in sync with Stripe events, and user-facing tools for managing subscriptions and payment methods. All sensitive operations (creating subscriptions, updating cards, etc.) are done server-side (via Next.js API routes or server actions), ensuring that secret keys are not exposed and that we have full control over the process. The integration also uses Stripe’s latest features like Checkout Sessions, Setup Intents, and the billing portal to minimize our PCI burden and provide a smooth user experience.

Developers working on this feature should primarily be aware of the key modules and their responsibilities: **`lib/stripe.ts`** for client config, **`userOnboarding.ts`** and \*\*`stripe-connect` API for Connect flows, **`subscription-plans.ts`** and collective plans API for creating offerings, **`subscribe/route.ts`** for handling the subscription purchase flow, **`stripe-webhook/route.ts`** for processing events, and **`stripe-actions/billing.ts`** plus the related components for payment method management. The code is well-structured with careful logging and error-handling, making it easier to troubleshoot issues in a complex domain like payments.
