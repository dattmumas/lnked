In addition, I will review the updated database schema and identify 10 additional opportunities for technical or architectural improvement.

I'll provide the output as a table with File, Problem, Solution, and Recommendation columns.

# Multi-Tenancy Update Plan

## Update API Routes to Use Tenant-Scoped Queries

**Issue:** Many API endpoints currently fetch or manipulate data without scoping to a tenant, risking cross-tenant data leakage. For example, older routes might query posts or conversations by collective ID only, or not at all, instead of using the new tenant context. The new schema adds a `tenant_id` field to most content tables (e.g. posts, comments), so queries must filter by it.
**Plan:** Refactor all API route handlers to enforce tenant scoping on database queries:

- **Include `tenant_id` filters:** Wherever data is fetched from Supabase, add an equality filter on `tenant_id` to match the current tenant. For instance, the tenant-scoped conversations route already does `.eq('tenant_id', tenantId)` when selecting conversations. All similar routes (posts, comments, etc.) should follow this pattern, either by using Supabase queries with `tenant_id` conditions or by calling secure RPCs that respect tenant context.
- **Use `withTenantAccess` wrapper:** Wrap handlers with the `withTenantAccess(tenantId, role, fn)` helper to automatically check that the user belongs to the tenant and has the minimum role required. This ensures that if a user tries to access a tenant’s data without membership (or insufficient role), the request is denied with a 403 error. The helper uses the `tenant_members` table to verify membership.
- **Nest routes under `/api/tenants/[tenantId]`:** Continue organizing new endpoints by tenant in the URL (as already done for posts, conversations, etc.) to make tenant context explicit. Deprecate any legacy endpoints that were not tenant-scoped (e.g. those under `/api/collectives`) or refactor them to call the new tenant-based routes internally.
- **Adjust query logic for multi-tenancy:** Remove any hard-coded collective filters and replace them with tenant filters. For example, if an endpoint previously did `.eq('collective_id', someId)`, it should now either use the tenant ID directly or join from collective to tenant if needed. In practice, if each collective is associated with a tenant (see below), queries can use that tenant ID to fetch relevant data.
- **Test isolation:** After updates, verify each route by attempting cross-tenant requests. For instance, using a valid session, try to GET posts from a tenant the user isn’t a member of – it should return an access error or empty result (as `withTenantAccess` would block it). Conversely, ensure that within the same tenant, data is accessible as before. This will confirm that all routes properly isolate data per tenant.

## Implement Tenant Switching with RPC Functions

**Issue:** Users need to seamlessly switch between their personal space and various collective spaces (tenants), but previously the app was tied to a single collective context. Now, the backend provides RPCs for tenant management (e.g. `get_user_personal_tenant`, `get_user_tenants`, `get_tenant_context`), which should be utilized to manage tenant state on the frontend. Without proper switching, data could load from the wrong tenant or not at all.
**Plan:** Introduce a **Tenant Switcher** in the UI that uses the new RPC functions to manage context:

- **Fetch all user tenants:** On app load, call the `get_user_tenants` RPC to retrieve the list of tenant memberships (personal and collective) for the current user. This returns an array of tenants the user belongs to, each with its ID, name, slug, type (personal or collective), etc. Store this in state.
- **Default to personal tenant:** Initialize the app’s current tenant context to the user’s personal tenant by default (every user has one). For example, the `useTenantSwitcher` hook already finds `personalTenant` from the fetched list and sets it as `currentTenantId` on first load. This ensures the user always has a valid tenant context (their own space) even if they haven’t joined any collectives.
- **Switch context on demand:** Provide a UI control (e.g. a dropdown in the navbar) listing all available tenants (personal + collectives) so the user can select one. When a new tenant is selected, update the global state/context with that tenant’s ID (using a hook like `useTenantSwitcher().switchTenant(tenantId)` which updates `currentTenantId`). This will trigger any tenant-dependent hooks or data fetches to reload under the new context.
- **Use `get_tenant_context`:** Whenever `currentTenantId` changes, fetch that tenant’s detailed context and the user’s role within it. The `useTenant` hook already handles this by calling `supabase.rpc('get_tenant_context', { target_tenant_id: ... })`. This RPC returns info like tenant name, slug, description, is_public, member_count, plus the `user_role` for the current user. Update application state with this info (e.g. store `currentTenant` object including permissions). This allows the UI to adjust based on role (e.g. only owners/admins see certain management options).
- **Handle unauthorized access:** If a user somehow attempts to switch to a tenant they don’t have access to (e.g. by manipulating the URL), the `useTenantAccess` hook or `withTenantAccess` on the backend will catch it and return an error. The UI should handle this gracefully – e.g. show an “Access Denied” message or redirect back to a valid tenant.
- **Refresh data on switch:** Ensure that when the tenant is switched, all relevant queries re-run for the new context. For example, refresh the posts feed, conversations list, etc., by leveraging React state or context updates. The provided hooks (`useUserTenants`, `useTenant`, etc.) already re-fetch data when their inputs change (e.g. `tenantId` dependency in `useTenant` effect). Verify that components subscribe to these hooks or the tenant context, so the UI updates automatically after a switch.
- **Testing:** Confirm that switching works by creating content in one tenant, switching to another tenant and verifying that the first tenant’s content is no longer visible. Also test creating a new collective (which should add a new tenant) and ensure it appears in the switcher list without a full reload (the `refreshTenants` function in `useUserTenants` can be called after creation to update the list). This will prove the tenant switching flow is smooth and reliable.

## Multi-Collective UI for Post Creation/Editing

**Issue:** Previously, a post could belong to only one collective (`collective_id` on the post). With multi-tenant support, a post can be shared across multiple collectives. The UI and form logic need to allow selecting multiple collectives for a single post, and the backend must create associations in the new junction table `post_collectives`. Currently, parts of the code support multi-select (e.g. form schema includes `selected_collectives` array), but the UI may still be limited or the data handling incomplete.
**Plan:** Update the post editor UI and logic to fully support multiple collective selections:

- **Form inputs:** Introduce a multi-select component in the post creation/edit form where the author can choose one or more collectives to share the post with. This might be a dropdown with checkboxes or a list of collective names the user has permission to post in. The `EnhancedPostEditorStore` already tracks `selectedCollectives` and `collectiveSharingSettings` in state; bind these to the new UI control. Ensure that if a user has no collectives (only personal), the UI either hides this field or indicates that the post will be personal-only by default.
- **Populate form data:** When the user selects or deselects collectives, update the form state accordingly. The store’s actions like `addCollective` and `removeCollective` update the `selected_collectives` array and corresponding settings in the form data. Leverage these actions to keep the UI in sync (for example, toggling a collective adds/removes it and marks the form as dirty).
- **Submission logic:** Adjust the create/update post server actions to handle multiple collectives. In the backend, after inserting/updating a post, insert entries into `post_collectives` for each selected collective. This is already partially implemented: after creating a post, the code upserts a record for each item in `selected_collectives` into `post_collectives`. We should verify this works for updates as well (e.g. if the user adds or removes collectives on edit, update the junction table accordingly – perhaps by comparing new vs. old selections and inserting or deleting as needed).
- **Legacy field handling:** The form still has a legacy single `collectiveId` for backward compatibility. Plan to phase this out: if a legacy collectiveId is provided (say, the post was originally in one collective), we can treat it as a pre-selected collective in the multi-select. The store has helpers `getLegacyCollectiveId` and a migration function to merge legacy data into the new multi-collective fields. Use these so that older posts (with `collective_id`) are initialized in the editor with that collective in the selection. New posts should ideally not use the singular `collectiveId` at all, except perhaps to derive a default tenant (see below).
- **Determine tenant context for new posts:** When creating a post, we still need to decide which tenant it “belongs” to for data isolation. The strategy will be to use the _primary_ collective or the user’s personal tenant as the `tenant_id`. In the current implementation, the code sets `tenant_id = collectiveId ?? user.id` as a placeholder – i.e. if posting to a collective, use that collective’s ID as the tenant, otherwise use the user’s ID (personal tenant). This should be replaced with a proper lookup: if one or more collectives are selected, pick the corresponding tenant ID (assuming collective and tenant IDs are unified, see below), or if none selected (personal post), use the personal tenant ID (which might be obtained via `get_user_personal_tenant`). This ensures the post’s `tenant_id` is correct.
- **UI feedback:** After successfully creating a post with multiple collectives, give feedback to the user. For example, redirect to the new post’s page and perhaps indicate on that page all the collectives it’s shared with. Each post in a list might also display badges or labels for the collectives it belongs to (which can be retrieved via a join on `post_collectives`). Make sure to only show those labels to users who have access to those collectives (in case of public vs private collective differences).
- **Testing:** Create a post and select multiple collectives. In the database, confirm that the `posts` row has the correct `tenant_id` and that the `post_collectives` table has an entry for each selected collective (with `post_id` and `collective_id` matching, etc.). Then verify that this post appears in the feeds of each respective collective (when viewing that collective’s tenant context). Also test editing: remove one collective and add another, save changes, and ensure the junction records update (the removed collective’s association is gone, the new one is added). The UI should reflect the updated selections when re-opening the editor. This will confirm the app properly supports multi-collective sharing end-to-end.

## Remove “Enhanced” Types in Favor of Generated Types

**Issue:** The codebase introduced custom “Enhanced” TypeScript types (in **`enhanced-database.types.ts`**) to represent the anticipated schema changes (such as the `post_collectives` table and multi-collective fields) before the database was updated. Now that the database schema is updated and a fresh `database.types.ts` is generated, these manual enhanced types are redundant and could drift from the actual schema. For example, the interface `EnhancedPostFormData` and the `EnhancedDatabase` extension were temporary constructs. Continuing to use them may cause confusion and extra maintenance.
**Plan:** Eliminate the manual enhanced types and switch to using the official generated types throughout the codebase:

- **Identify usage of enhanced types:** Search for any imports from `enhanced-database.types.ts`. One example is the post editor store, which imports `EnhancedPostFormData` and related types. Also, utility functions or components might reference `EnhancedDatabase` or types like `PostCollectiveRow`. Compile a list of these references.
- **Replace with generated types:** For each usage, determine the equivalent type from the new `Database` schema. Since the `post_collectives` table now exists in the `Database` type, we can use `Database['public']['Tables']['post_collectives']` types for its rows or inserts instead of the custom `PostCollectiveRow`. In many cases, the enhanced types were extending `Database` anyway, e.g. `EnhancedDatabase` added a `post_collectives` table definition – this is now unnecessary because `Database['public']['Tables']` already has `post_collectives`. So we can refactor code to use the types in `database.types.ts` (which is re-exported under `@/types/database.types`).
- **Update form data types:** The `EnhancedPostFormData` included multi-collective fields for the editor form. Now that the form schema (Zod) defines `selected_collectives` and related fields, we can derive a type from that schema instead of using the interface. Alternatively, define a new interface for post form state that mirrors the Zod schema (title, content, etc., plus `selected_collectives` array) and use it in the store, removing any mention of `EnhancedPostFormData`. In the store code, this is already done via an Omit/Extend to add `metadata` field – we can simplify that by using a type from the schema or constructing a clean type for form state.
- **Remove the enhanced types file:** Once all references are replaced, delete `enhanced-database.types.ts` to avoid confusion. Also remove the `EnhancedPostEditorStore` if it was purely for the transitional state; or if the store is still useful, rename it appropriately and refactor it to use the new types. For instance, the store’s state could use `PostFormValues` (from Zod schema) for formData, plus extra UI state, instead of `EnhancedPostFormData`.
- **Verify type consistency:** Run the TypeScript compiler or build process to catch any errors from the refactoring. Pay special attention to cases where the enhanced types had slight differences. For example, `EnhancedPostFormData.post_type` was using an enum from Database – ensure the generated types provide the same (likely `Database['public']['Enums']['post_type_enum']`). Also, the enhanced types had some fields like `collective_sharing_settings` (a record of collective-specific settings) which might not exist directly in the database schema. Those are likely only used in the front-end, so we can keep such definitions in the front-end context (perhaps as part of form state types) without tying them to the Database type.
- **Test after removal:** Since this is a type/system change, ensure the app still behaves correctly. Create posts, share to collectives, etc., to make sure that removing the enhanced types did not break any runtime logic. In practice, it should not, because those types are compile-time only. The benefit is simplifying the code and ensuring we rely on the single source of truth (the generated schema types) for all database structures.

## Test Multi-Tenancy Data Isolation

**Issue:** After all these changes, we need to rigorously verify that multi-tenancy truly isolates data between tenants. This means a user in one tenant (collective or personal) should not see or affect data in another tenant unless explicitly allowed (e.g. a public collective’s content might be visible read-only). Even with code updates, misconfigurations (like missing RLS policies or logic oversights) could leave holes. Ensuring data isolation is crucial for security and correctness in a multi-tenant system.
**Plan:** Conduct comprehensive testing of tenant isolation across the application:

- **Role-based API tests:** Simulate requests to various `/api/tenants/{tenantId}/...` endpoints with a user who is **not** a member of that tenant. These should all be blocked. For example, if user A is only in tenant X, calling the posts API for tenant Y should return an error. The `withTenantAccess` mechanism will produce a “No access to this tenant” error in such cases, which should translate to a 403 HTTP response. Verify that this holds true for reading data, as well as attempting writes (creating or editing content in another tenant).
- **UI behavior for unauthorized access:** In the UI, try to manually construct a URL to a tenant’s page that the logged-in user doesn’t belong to (e.g. `/dashboard/collectives/some-other-slug`). The app should either not allow navigation to it, or show an appropriate error/empty state. Because we use `useTenant` and `useTenantAccess` hooks on the client, the user likely will get redirected or see “access denied” if they somehow get there – confirm this is the case. For public tenants (if `is_public` is true), non-members might be allowed read-only access; ensure the backend RPCs handle that (the `get_tenant_context` or other policies might need to consider `is_public`).
- **Cross-tenant content checks:** Create distinct test data in different tenants and ensure there’s no crossover. For instance, have user A create a post in collective 1 (tenant1) and user B (who is in collective 2, tenant2) create a post there. Each user should only see their respective post when in their tenant context. Use the search or discover functionality to confirm that tenant scoping is applied; e.g. if there’s a global search feature, it likely should only search within the current tenant unless explicitly designed to search public content globally. If the search endpoint or logic isn’t yet tenant-aware, mark that as a bug to fix (e.g., by adding `tenant_id` filter in full-text queries or separate indexes per tenant).
- **Data creation and membership:** Ensure that when new collectives (tenants) are created, the creator is properly associated as a member so they can immediately access it. We should test the flow of creating a collective and then using the app as that collective’s owner: the owner should be able to switch into the new tenant and perform actions, and other users should not see that tenant until they are invited. If any step fails (for example, if the owner wasn’t added to `tenant_members` due to a missed piece of logic), that will surface here. (In the current code, creating a collective via the old path might not insert a tenant membership, which would be an issue to fix – see improvement #1 below).
- **Review RLS policies:** In addition to application-level checks, verify the database’s Row-Level Security rules. Each table with a `tenant_id` should have RLS enabled to restrict rows to members of that tenant. For example, a policy on the `posts` table might allow access if `auth.uid()` is a member of `posts.tenant_id`. If such policies are not yet in place (because the code is using a service role for server-side queries), plan to add them especially for any direct client-side access. This adds a safety net. After adding RLS, re-run the above tests to ensure the outcome is the same (and adjust policies if something that should be allowed is blocked, or vice versa).
- **Automated testing:** It’s wise to encode these isolation tests in an automated test suite. For instance, write integration tests that call APIs with various tenant IDs and assert correct status codes (some test files already exist, e.g. `route.test.ts` for conversations). Add new tests for posts and other routes to cover multi-tenancy scenarios. This will prevent regressions in the future. By the end of this testing phase, we should be confident that each tenant’s data is walled off, fulfilling the multi-tenancy requirement.

# Additional Areas for Improvement

Beyond the specific issues above, a review of the updated database schema and codebase reveals further opportunities to improve consistency, performance, and maintainability. Below are 10 other areas, each described with the issue and a proposed plan:

1. **Collective Creation Not Tenant-Aware:** Currently, creating a new collective via the server action does not create a corresponding tenant entry. The code inserts into `collectives` and `collective_members` (for the owner) but knows nothing of the `tenants` table. This means the new collective’s data isn’t isolated under a tenant, and it won’t appear in tenant-based queries or the user’s tenant list.
   **Plan:** Modify the collective creation flow to utilize the new RPC (or equivalent logic) for tenant creation. Instead of a direct insert, call `create_collective_tenant` (which expects a name, slug, description, is_public) so that a row is added to the `tenants` table. Ensure this RPC also inserts the collective info and the owner’s membership in `tenant_members`. If `create_collective_tenant` currently returns just a tenant ID, use that ID to route the user appropriately. We may deprecate the old `createCollective` action – or have it internally call the RPC – to avoid duplicate code. After this change, whenever a collective is created, there will be a matching tenant and the collective’s owner will automatically have the proper access in the new tenant. This keeps `collectives` and `tenants` in sync and allows the rest of the system (which relies on tenant IDs) to immediately work with the new collective space.

2. **Unify Collective ID and Tenant ID:** There is potential confusion if collectives and tenants use separate IDs. Ideally, each collective’s `id` (primary key) **is** the tenant ID for its data. If this is not already the case, it can lead to mismatches. For instance, in the post creation, the code currently sets `tenant_id = collectiveId`, implicitly assuming the collective’s ID can serve as the tenant identifier. If in reality the `tenants.id` is different, posts might get a wrong tenant_id.
   **Plan:** Ensure that for every collective, the `tenants` table contains an entry with the same ID (or at least a clear mapping). The simplest approach is to use the collective’s UUID as the tenant UUID. The `create_collective_tenant` function can handle this by generating one UUID and inserting it into both the `tenants` and `collectives` tables. If we have existing data where they diverge, consider adding a foreign key on `collectives` to reference `tenants` (or vice versa) and store the tenant ID in the collective record. Then update code to use that mapping. For example, `collectives` could have a column `tenant_id` referencing the `tenants` table. However, maintaining two IDs is suboptimal – using one ID system for both is cleaner. After unification, remove any workaround where a tenant ID is jammed into a collective field or vice versa. This way, whenever a collective is selected in the UI, we inherently know the tenant ID (it’s the same value), and there’s no ambiguity in queries or data inserts.

3. **Sync Membership Between `collective_members` and `tenant_members`:** With both tables in play, there’s a risk of inconsistent membership data. Currently, adding a user to a collective (e.g. invite or join) likely only inserts into `collective_members`. If we rely on `tenant_members` for access control (as `checkTenantAccess` does), missing entries there would block legitimate members.
   **Plan:** Consolidate membership management on one source. Ideally, deprecate `collective_members` in favor of `tenant_members` for consistency. This could mean: whenever a user is added to a collective, ensure an entry is created in `tenant_members` with the collective’s tenant ID and the user’s ID (with an appropriate role). The `create_collective_tenant` RPC should already add the owner to `tenant_members`. We should extend similar logic to collective invitations or joins. Conversely, when removing a member, remove from both tables. In the short term, we might implement dual writes (update both tables) to keep things synced. In the long term, if tenants fully subsume collectives, we might drop `collective_members` entirely. As a safeguard, we can run a one-time migration script: iterate all collective_members and insert corresponding tenant_members for any that are missing, so no one loses access after the switch. After these changes, adjust permission checks in code to reference `tenant_members` only (for example, the permission check in `validateCollectivePermissions` can be replaced or supplemented with a tenant_members query).

4. **Row-Level Security (RLS) Policies for Multi-Tenancy:** Relying solely on application logic to enforce tenant isolation can be error-prone. If a developer forgets a `.eq('tenant_id', ...)` filter, data could leak. Supabase allows RLS policies which are a last line of defense.
   **Plan:** Define and enable RLS policies on all tables that include `tenant_id`. For instance, on the `posts` table, a policy could allow SELECT/UPDATE/DELETE if `auth.uid()` is a member of that post’s tenant (which can be checked via a join or Supabase’s function context). On `tenant_members`, allow users to see only their own entries (or perhaps an admin can see all members of tenants they admin). Since our server code often uses service role (especially in Next.js server components), we might need to ensure we switch to user role for certain client-side calls or explicitly call RPCs that enforce RLS. This might require some architecture (Supabase’s client can use the user’s JWT which triggers RLS). We should test with RLS on to ensure that, for example, a user querying their own supabase client cannot retrieve another tenant’s data. If any automated process (like the `get_user_tenants` RPC) runs as security definer and bypasses RLS, that’s fine, as long as it only returns intended data. In summary, adding RLS is an improvement for security: even if the app code has a bug, the database won’t return cross-tenant rows. Document these policies for the team and include them in the infrastructure setup so they’re not lost.

5. **Optimize Tenant Context Fetching:** We currently call `get_tenant_context` on each relevant API request (e.g. fetching posts calls it to attach tenant info to each post). This provides useful data like tenant name/slug and user role for that tenant. However, calling it repeatedly can be inefficient, and doing it inside a loop of posts is unnecessary since the context is the same for all posts in that tenant.
   **Plan:** Refactor so that tenant context is fetched once per request or page load, rather than per item. For example, in the posts feed API, the code fetches tenant context after getting posts, which is fine (it’s outside the loop). But ensure we don’t inadvertently call it for every post. Also, consider caching tenant info for short durations. The `useTenant` hook on the client already stores the fetched context in state so it’s not re-fetched until `tenantId` changes. We could extend this idea to the server: maybe cache `tenantId -> {name, slug, type}` mappings in memory (or use Supabase’s caching via `pg_temp` or a Redis if available). This is a performance enhancement to reduce latency, especially if a user switches contexts often or if pages make multiple tenant info calls. Ensure that any caching respects updates (e.g. if a collective changes name, the cache should invalidate – perhaps tie cache to `updated_at` of tenant).

6. **Introduce Post `slug` Field and URLs:** As noted in the code TODO, posts currently do not have a dedicated slug field. The application generates a slug from the title at creation time (and appends a timestamp to ensure uniqueness), but that slug isn’t stored in the database – it’s only used for constructing the URL returned to the client. This means we rely on the post ID or the cached slug in memory for linking, and changing a post’s title could break existing links.
   **Plan:** Add a `slug` column to the `posts` table (and consider a unique index on it, perhaps scoped per tenant if we want slugs unique only within a tenant’s namespace). Modify the createPost logic to include generating and saving the slug. Update the `resolveSlugConflict` function to check the database for existing slugs (within the same tenant) instead of blindly appending timestamp. For updates, implement the concept of slug history or redirection: if a post’s title (and thus desired slug) changes, we could keep the old slug in a separate table (e.g. `post_slugs` with post_id, old_slug, changed_at). Then, when someone visits an old URL, the app can look up that table to find the new location. This is a more advanced feature, but at minimum storing the slug in the posts table is a start. Once in place, update all frontend links to use `post.slug` (along with maybe the tenant or collective slug for context) instead of constructing from title each time. Test by creating two posts with the same title in the same tenant – the slug generator should produce distinct slugs and save them. Also test editing a title: either lock the slug to original (common approach) or update it and add a redirect entry.

7. **Clean Up Legacy Fields (`collective_id`, `sharing_settings`):** Now that multi-collective is implemented via `post_collectives`, the original `posts.collective_id` and `posts.sharing_settings` (a JSON field) are candidates for deprecation. The `collective_id` on posts can cause inconsistency if a post is in multiple collectives – which one does this field refer to? It may hold the first collective or the original collective if migrated, but it’s redundant. `sharing_settings` was presumably used to store per-collective sharing options in JSON, which is now handled by the `post_collectives.metadata` and status fields.
   **Plan:** Gradually remove usage of these fields. In code, avoid writing to or reading from `posts.collective_id` except where absolutely needed for backward compatibility (maybe some UI still shows a primary collective for a post). Instead, retrieve the list of collectives via `post_collectives`. For `sharing_settings`, if it’s not used elsewhere, plan a database migration to drop it from the posts table. If it was storing something essential (like auto-publish flags per collective), ensure that data now lives in `post_collectives.metadata`. The Enhanced store was populating `collective_sharing_settings` for the form; after publishing, that data is likely saved in the junction table rather than in posts.sharing_settings (the code upserts only basic fields, not the full settings yet). We may need to extend the insert to include those settings in the `metadata` column of `post_collectives`. Once that’s done, we can drop `sharing_settings` completely. Similarly, consider removing `collective_id` from posts once we’re confident everything references the new structure. This might involve updating foreign keys (e.g. `collectives.pinned_post_id` currently points to a post’s ID – that’s fine, but if `collective_id` was used to filter posts for a collective’s timeline, that should switch to using `post_collectives`). The removal will simplify the data model and avoid confusion over which field is authoritative for a post’s collective membership.

8. **Public vs Private Content and Tenants:** The schema and RPC suggest an `is_public` flag on tenants and content. We should clarify how public content is handled in a multi-tenant scenario. For instance, a collective (tenant) might be marked `is_public = true` meaning its content can be viewed by non-members (read-only), or a post might be `is_public = true` meaning it’s meant for broader visibility. Right now, the code’s interpretation is that a “published” post (status active and is_public true) is visible to anyone with at least member access – but if the collective is private, perhaps even members-only posts shouldn’t be shown to non-members.
   **Plan:** Refine the access rules for public content. If we want certain collectives to be open, implement logic such that if a tenant is public, the `withTenantAccess` check for read operations could allow non-authenticated or non-member users to fetch data (maybe with `requiredRole = null` or a separate path that bypasses membership). This could be done with a special case: e.g. in `checkTenantAccess`, if tenant is public and the operation is a read, treat it as accessible (possibly with `userRole = 'guest'`). We would need to fetch `tenants.is_public` in those cases (maybe that’s part of `get_tenant_context` already). For content-level `is_public`, continue to use it to filter posts that are meant to be published vs draft. But also consider that a collective might want a mix (some posts members-only, some public). That would require checking both flags: e.g. if a post is marked public but it lives in a private collective, perhaps only members see it – or maybe we allow sharing specific posts publicly via a different mechanism (like generating a public link). This requires product decision, but at least align the code with an initial interpretation: likely **collective’s** `is_public` governs overall visibility, and post’s `is_public` indicates if it’s published within that scope. We should implement accordingly and document it. Then test: mark a collective as public, log out or use another account not in the collective, and try to view its posts (should be allowed if posts are published). Mark collective as private, ensure non-members cannot see posts even if `is_public` on post is true. Adjust policies or code as needed based on these tests.

9. **Performance Tuning for Tenant Queries:** As data grows, certain queries might become slow, especially those filtering by tenant with additional ordering or aggregation. For example, listing posts by `tenant_id` with sorts on `like_count` or full-text search on `tsv` could benefit from composite indexes (tenant_id + sort key, or a partitioning by tenant). Supabase doesn’t natively partition by tenant, but we can add indexes.
   **Plan:** Review index usage on new multi-tenant queries. On the `posts` table, we should have an index on `tenant_id` (if not already via primary key that includes it). If we frequently query “recent posts in tenant by created_at desc”, an index on `(tenant_id, created_at)` is helpful. Similarly for `like_count` or other sort fields. The `post_collectives` table might need an index on `collective_id` (to quickly fetch all posts for a given collective) and on `post_id` (to find all collectives for a post). Check Supabase auto-generated indices; if any are missing, add them via migration. Additionally, if we implement the slug field unique per tenant, create a unique index on `(tenant_id, slug)` for posts. For full-text search on posts, ideally include tenant as part of the query (which we will) – if needed, maintain a separate tsv for each tenant, or just rely on the filter. Consider using Supabase’s full-text search capabilities with config by tenant if possible. After adding indexes, use EXPLAIN on some representative queries (perhaps via a Supabase function or console) to ensure query plans are efficient. This preventative tuning will keep the app snappy as multi-tenant data scales up.

10. **Improve Error Handling and Retries:** Multi-tenancy operations (like creating a post with multiple collectives, or switching tenants) involve more steps and thus more points of failure. We saw in the post creation that if adding to `post_collectives` fails, it currently logs an error but does not roll back the post itself. Similarly, the collective creation notes that failure to add the owner as member just logs a warning. These could leave data in inconsistent states.
    **Plan:** Introduce transactionality or compensating actions for multi-step operations. Supabase now supports some level of transaction via their RPC (or we could use an edge function with a single transaction). For creating a post, ideally the insertion of the post and its collective associations should be atomic. If `post_collectives` insert fails, we might want to delete the created post (to avoid a post with no collective context in a collective-only tenant). Implement this cleanup explicitly: after a `post_collectives` failure, call a deletion on that post ID (the code partially does this for conversation creation rollback). For collective creation, if adding the owner to tenant_members fails, consider deleting the collective/tenant or retrying immediately. Better, wrap the whole create-collective logic in a database function that either inserts all or nothing. For the thumbnail cleanup example, they mention implementing a retry queue – we can integrate a job scheduler or at least re-attempt deletion later (perhaps store failed deletion paths in a table or use a third-party service). Also, improve error surfacing: if a multi-collective post partially fails, inform the user that some shares failed (the current code just logs it but returns success to user). We can collect errors and include them in the response so the UI could, for example, show “Post created, but failed to share with Collective X.” By making these changes, we strengthen the reliability of the system under the more complex multi-tenant operations.

Each of these improvements will bring the codebase and database closer to a robust multi-tenant architecture, aligned with the new schema. By addressing them, we reduce technical debt introduced during the transition (such as parallel data structures and temporary hacks) and ensure the system is maintainable going forward.
