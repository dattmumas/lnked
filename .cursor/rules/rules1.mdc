---
description: 
globs: 
alwaysApply: true
---
Adhere to Next.js 13 App Router conventions: Organize files by feature and route, using the App Directory structure (e.g. page components in src/app/** and co-located page.tsx, layout.tsx, etc.) per Next.js best practices. Prefer Server Actions over API routes for form submissions and mutations that only the app itself needs (this keeps logic type-safe and reduces extra API layers). Use Next’s built-in features like Route Handlers for the few cases where external clients or webhooks require an API endpoint. Docs: Refer to the Next.js App Router official docs for guidance on file structure and new patterns (e.g. using use server directives) to ensure we leverage Next 13 capabilities correctly.
Supabase integration and RLS: Use Supabase as the single source of truth for data, and respect its Row-Level Security (RLS) rules on the database side. On the server, utilize the Supabase Admin client for privileged actions (like in server actions) and the regular client for user-level queries – this matches how we create server and browser clients (createServerSupabaseClient, etc.). Avoid duplicating security logic in the app when RLS can enforce it in the DB. For example, rather than filtering by user ID in every query, define policies in Supabase and simply call .select() as the authenticated user. Always handle Supabase responses and errors robustly (log errors from .from(...).select() calls, etc., as seen in our API routes
github.com
). Docs: See Supabase’s documentation on RLS policies and using the JS client in Next.js for best practices on secure data access and efficient queries.
Lexical editor usage: Now that the editor is simplified, follow Lexical’s plugin architecture wisely – load only the plugins needed for desired functionality. For any new rich text feature, consult the Lexical Plugin Docs (e.g. how to implement mentions, links, etc.) instead of pulling in the entire playground. Keep editor components small and focused: for instance, if adding a new node (like a custom embed), define it in a dedicated module and register it in the Lexical composer config, rather than reintroducing a big suite of nodes. Regularly update Lexical to benefit from improvements (ensuring we test after upgrades due to its rapid development). Docs: The Lexical official guides on creating plugins and nodes (on lexical.dev) are a great reference to ensure we implement new editor features in line with recommended patterns.
Component composition and file organization: Continue using a modular approach for UI components – e.g., small “atom” components in components/ui, feature-specific components grouped under feature folders (as done with posts, collectives, etc.). Avoid duplicating code: if a piece of UI or logic is needed in multiple places, factor it into a common component or utility. For example, if after cleanup we wanted to reintroduce a “LikeButton” for both posts and comments, we’d create a single reusable component rather than two copies. Leverage Next.js dynamic import and React Server Components to keep the app performant (e.g., heavy client-only components can be lazy-loaded). Ensure server actions and components remain in appropriate places – long-running or sensitive tasks belong in server actions (with the use server directive), while lightweight interactive UI stays on the client. This separation aligns with Next’s guidance and keeps the app efficient.
Agentic coding principles for Cursor: Encourage the AI assistant (Cursor) to adopt a thoughtful, reasoning-driven approach when modifying code. This means always analyzing dependencies before deletion or refactor – e.g., if asked to remove a module, Cursor should first confirm no other module imports it. In pull requests, provide clear justification in commit messages (e.g. “Removed unused ChatInterface component to streamline codebase”). Follow the project’s coding style and conventions strictly so that AI-generated code blends in seamlessly (use the existing naming patterns, abide by lint rules). The assistant should also feel empowered to ask for clarification (via comments or in its reasoning process) if a task is ambiguous – it’s better to pause than to guess and introduce a bug. By acting as a reasoning agent rather than a code generator, Cursor will produce changes that are easier for human collaborators to review and trust. Finally, always run tests and verify the app after automated changes; an agentic coder double-checks its work. Docs/References: See the Next.js, Supabase, and Stripe docs as needed during implementation, and use the project’s README or architecture docs (if available) to align with overall design decisions.