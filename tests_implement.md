| **Filename**                                                                           | **Recommended Test API**       | **Recommended Test Purpose**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | **Example Test Code**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| -------------------------------------------------------------------------------------- | ------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `src/components/ui/ReactionButtons.tsx`                                                | React Testing Library (Vitest) | Unit test for UI reaction logic, ensuring optimistic update on click and rollback on failure. This covers that likes/dislikes update immediately and revert if the server response fails.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | render(<ReactionButtons id="post1" initialLikeCount=0 initialDislikeCount=0 initialUserReaction={null} reactionHandler={vi.fn().mockResolvedValue({ success: false })} />);\nuserEvent.click(screen.getByLabelText('Like'));\nexpect(screen.getByText('1')).toBeInTheDocument(); // optimistic +1\nawait waitFor(() => expect(screen.getByText('0')).toBeInTheDocument()); // reverted on failure                                                                                                                                                                                                                                                                                                                     |
| `src/components/app/posts/molecules/PostReactionButtons.tsx`                           | React Testing Library (Vitest) | Unit test for integrating post reactions with API. Verify that clicking like/dislike triggers a fetch to the `/api/posts/:id/reactions` endpoint and updates counts.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | global.fetch = vi.fn().mockResolvedValue({ ok: true, json: async () => ({ likeCount: 1, dislikeCount: 0, userReaction: 'like' }) });\nrender(<PostReactionButtons id="post123" initialLikeCount=0 initialDislikeCount=0 initialUserReaction={null} />);\nuserEvent.click(screen.getByLabelText('Like'));\nawait waitFor(() => expect(fetch).toHaveBeenCalledWith('/api/posts/post123/reactions', expect.any(Object)));                                                                                                                                                                                                                                                                                                |
| `src/lib/utils/reactionHelpers.ts`                                                     | Vitest (unit)                  | Unit test for pure reaction state logic. For example, test that toggling a like when user already liked will remove the like, and that counts increment/decrement correctly.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | expect(toggleReactionState({ likeCount: 5, dislikeCount: 2, userReaction: undefined }, 'like')).toMatchObject({ newLikeCount: 6, newUserReaction: 'like' });\nexpect(toggleReactionState({ likeCount: 6, dislikeCount: 2, userReaction: 'like' }, 'like')).toMatchObject({ newLikeCount: 5, newUserReaction: undefined });                                                                                                                                                                                                                                                                                                                                                                                            |
| `src/app/api/posts/[slug]/reactions/route.ts`                                          | Supertest (integration)        | Integration test for the post reactions API. Verify that a POST request by an authenticated user toggles the reaction and returns updated like/dislike counts. Also ensure unauthorized requests are rejected (e.g. 401) and that invalid inputs yield 400.                                                                                                                                                                                                                                                                                                                                                                                                                     | await supertest(app).post('/api/posts/abc123/reactions').set('Authorization', token).send({ type: 'like' }).expect(200);\nawait supertest(app).post('/api/posts/abc123/reactions').send({ type: 'like' }).expect(401); // no auth                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| `src/lib/data-access/video.repository.ts`                                              | Vitest (integration)           | Integration test for Supabase DB operations on videos. Use a stub or test database to verify that creating, updating, and deleting videos behave correctly. For example, test that `create()` returns a parsed VideoAsset on success and `undefined` on error, and that `delete()` returns `true` when the video is soft-deleted.                                                                                                                                                                                                                                                                                                                                               | const fakeClient = {\n from: () => ({ insert: () => ({ select: () => ({ single: async () => ({ data: { id: 'v1', title: 'Test' }, error: null }) }) }) })\n} as any;\nconst repo = new VideoRepository(fakeClient);\nconst video = await repo.create({ id: 'v1', title: 'Test' });\nexpect(video?.id).toBe('v1'); // created successfully\nfakeClient.from = () => ({ update: () => ({ eq: () => ({ error: null }) }) });\nexpect(await repo.delete('v1')).toBe(true);                                                                                                                                                                                                                                                |
| `src/lib/data-access/schemas/video.schema.ts`                                          | Vitest (unit)                  | Unit test for video data Zod schemas. Validate that the schema correctly accepts valid video objects and rejects invalid ones (e.g. missing required fields or wrong types). This ensures data parsing (e.g. via `parseVideoAsset`) works as expected.                                                                                                                                                                                                                                                                                                                                                                                                                          | expect(() => VideoInsertSchema.parse({ title: 'Ok', mux_asset_id: null })).toThrow(); // missing required fields\nexpect(VideoInsertSchema.parse({ title: 'T', description: null, mux_asset_id: 'x', mux_playback_id: 'y' })).toHaveProperty('title', 'T');                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| `src/app/api/videos/route.ts`                                                          | Supertest (integration)        | Integration test for listing/creating videos. Ensure that `GET /api/videos` returns a paginated list of videos for an authenticated user (and does not leak private/deleted videos), and that `POST /api/videos` (if implemented) requires auth and properly creates a video record. Include tests for query parameters (pagination, filters) and that unauthorized access is 401.                                                                                                                                                                                                                                                                                              | await supertest(app).get('/api/videos?page=1&limit=2').set('Authorization', token).expect(200);\nawait supertest(app).get('/api/videos').expect(401); // not logged in                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| `src/app/api/videos/[id]/route.ts`                                                     | Supertest (integration)        | Integration test for video detail/updates. Test that `GET /api/videos/:id` returns video data if the requester has access (owner or allowed collective member) and 403/404 if not. For `PATCH` (update) requests, verify that only the video owner can update metadata and that the changes persist (e.g. title changes). For `DELETE`, verify soft-delete: the response is 202/204 and the video’s `deleted_at` is set and content anonymized.                                                                                                                                                                                                                                 | await supertest(app).get('/api/videos/vid123').set('Authorization', ownerToken).expect(200);\nawait supertest(app).get('/api/videos/vid123').set('Authorization', otherUserToken).expect(403);\nawait supertest(app).delete('/api/videos/vid123').set('Authorization', ownerToken).expect(202);                                                                                                                                                                                                                                                                                                                                                                                                                       |
| `src/app/api/videos/[id]/signed-url/route.ts`                                          | Vitest (integration)           | Integration test for private video access. Simulate a GET request for a signed URL for a private video. Ensure that an authorized user (owner or a permitted collective member) receives a URL (e.g. JWT token string) and unauthorized users get 403. Also test that if the video is public, the route might return an error or not be needed (depending on implementation).                                                                                                                                                                                                                                                                                                   | const res = await GET(new Request('[http://.../api/videos/vid123/signed-url](http://.../api/videos/vid123/signed-url)'), { params: { id: 'vid123' }, headers: { Authorization: bearerToken } });\nconst data = await res.json();\nexpect(data.signedUrl).toMatch(/^[https://stream.mux.com/](https://stream.mux.com/));                                                                                                                                                                                                                                                                                                                                                                                               |
| `src/app/api/videos/upload-url/route.ts`                                               | Vitest (integration)           | Integration test for the video upload initiation flow. When posting video details (title, etc.), ensure it creates a new video record and returns an `uploadUrl` and video info. Mock the Mux API call so it returns a test upload URL. Test that missing fields or invalid data yield 400, and unauthorized requests yield 401.                                                                                                                                                                                                                                                                                                                                                | const muxStub = { video: { uploads: { create: vi.fn().mockResolvedValue({ url: '[https://test-upload-url](https://test-upload-url)' }) } } };\n// Inject muxStub into the route's Mux client if possible\nconst res = await POST(new Request('[http://.../api/videos/upload-url](http://.../api/videos/upload-url)', { body: JSON.stringify({ title: 'Test', description: 'Desc', privacy_setting: 'public' }) }), { /_ ...auth context... _/ });\nconst body = await res.json();\nexpect(body.uploadUrl).toContain('[https://test-upload-url](https://test-upload-url)');                                                                                                                                            |
| `src/app/api/videos/user/[userId]/route.ts`                                            | Supertest (integration)        | Integration test for fetching a user's videos. Ensure that a logged-in user can retrieve their own videos list and that the endpoint properly filters by userId. Also ensure that one user cannot fetch another user’s private videos (should be empty or forbidden due to RLS). Use a test user with known video entries to verify the response.                                                                                                                                                                                                                                                                                                                               | await supertest(app).get('/api/videos/user/u1').set('Authorization', tokenForUser1).expect(200).then(res => {\n expect(res.body.data.videos.every(v => v.created_by === 'u1')).toBe(true);\n});                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| `src/app/videos/[id]/page.tsx`                                                         | Playwright (E2E)               | End-to-end test for video viewing. Simulate a user navigating to a video’s page. Verify that the video player loads (or shows a loading indicator for private videos) and that the title/description are displayed. If the video is private, test that unauthorized users cannot play it (e.g., ensure an error message or redirect).                                                                                                                                                                                                                                                                                                                                           | await page.goto('/videos/vid123');\nawait expect(page).toHaveText('Video Title');\nconst player = await page.locator('video');\nawait expect(player).toBeVisible();                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| `src/components/app/video/VideoPlayerClient.tsx`                                       | React Testing Library (Vitest) | Unit test for basic video player rendering. Ensure that given a video object (id, playback_id, etc.), it renders a video player component (e.g., the Mux player or HTML5 video) and displays the title or other metadata. If this component is primarily a wrapper, verify it passes props correctly to the underlying player.                                                                                                                                                                                                                                                                                                                                                  | const video = { id: 'v1', title: 'Test Video', mux_playback_id: 'xyz', is_public: true };\nrender(<VideoPlayerClient video={video} />);\nexpect(screen.getByText('Test Video')).toBeInTheDocument(); // title shown\nexpect(screen.getByRole('video')).toBeInTheDocument();                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| `src/components/app/video/MuxVideoPlayerEnhanced.tsx`                                  | React Testing Library (Vitest) | Unit test for private video playback handling. Verify that when `isPrivate` is true, it initially shows a loading state and fetches a signed URL. Mock `fetch` to return a dummy signed URL JSON. Ensure that upon success, the loading spinner disappears and the `<MuxPlayer>` is rendered with the `src` set to the signed URL. Also test the error path: make `fetch` return an error and verify an error message renders.                                                                                                                                                                                                                                                  | global.fetch = vi.fn().mockResolvedValue({ ok: true, json: async () => ({ signedUrl: '[https://signed-url](https://signed-url)' }) });\nrender(<MuxVideoPlayerEnhanced playbackId="publicId" videoId="vid123" isPrivate title="Private Video" />);\nexpect(screen.getByText('Loading video...')).toBeInTheDocument();\nawait waitFor(() => expect(fetch).toHaveBeenCalledWith('/api/videos/vid123/signed-url', expect.any(Object)));\nawait waitForElementToBeRemoved(() => screen.queryByText('Loading video...'));\nexpect(screen.getByText('Private Video')).toBeInTheDocument(); // title visible when loaded                                                                                                     |
| `src/components/app/video/MuxVideoPlayerClient.tsx`                                    | React Testing Library (Vitest) | Unit test for the standard Mux video player component. Ensure it renders the Mux player with the given `playbackId` for public videos. For example, check that the underlying `<MuxPlayer>` or `<video>` element has the correct `src` or `playbackId` prop.                                                                                                                                                                                                                                                                                                                                                                                                                    | render(<MuxVideoPlayerClient playbackId="abcd123" title="Demo Video" />);\nconst muxElement = screen.getByTitle('Demo Video');\nexpect(muxElement).toBeInTheDocument(); // player rendered\n// If MuxPlayer is used, ensure playbackId passed\nexpect(muxElement.getAttribute('playbackid')                                                                                                                                                                                                                                                                                                                                                                                                                           |
| `src/components/app/video/MuxVideoPlayerSimple.tsx`                                    | React Testing Library (Vitest) | Unit test for the simplified video player (perhaps a lighter UI). Confirm it renders a video element or Mux player with minimal controls. If it has any specific props (like no controls or different styling), ensure those are reflected.                                                                                                                                                                                                                                                                                                                                                                                                                                     | render(<MuxVideoPlayerSimple playbackId="xyz789" />);\nconst videoEl = screen.getByRole('video');\nexpect(videoEl).toBeInTheDocument();\n// e.g., ensure controls prop is false if it's a simple embed\nexpect(videoEl).toHaveAttribute('controls', 'false');                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| `src/components/app/video/wizard/VideoUploadForm.tsx`                                  | React Testing Library (Vitest) | Integration test for the video upload form (single-step). Simulate a user filling out the form: entering title, selecting a file, choosing privacy, etc., then clicking "Upload". Mock the API call to `/api/videos/upload-url` to return a fake upload URL and video ID. Verify that upon submission, the `onComplete` callback is called with the new video ID (and that the form shows any relevant success or navigates appropriately). Also ensure validation errors appear if required fields are missing.                                                                                                                                                                | const onComplete = vi.fn();\nrender(<VideoUploadForm onComplete={onComplete} onCancel={() => {}} />);\nawait userEvent.type(screen.getByLabelText(/Title/), 'My Video');\n// ...simulate selecting a file via file input...\nuserEvent.click(screen.getByRole('button', { name: /Upload/i }));\n// Assume successful response triggers onComplete\nawait waitFor(() => expect(onComplete).toHaveBeenCalledWith(expect.stringMatching(/[0-9a-f-]{36}/)) );                                                                                                                                                                                                                                                             |
| `src/components/app/video/wizard/VideoUploadWizard.tsx`                                | React Testing Library (Vitest) | Unit test for the multi-step video upload wizard (if still used). Simulate navigating through steps: ensure that going to the next step carries over form state. For example, after entering details in SettingsStep, moving to PreviewStep shows the entered info. Also test the cancel flow and that the wizard can submit at the end, calling the appropriate handler.                                                                                                                                                                                                                                                                                                       | render(<VideoUploadWizard />);\nexpect(screen.getByText('Video Details')).toBeInTheDocument(); // first step\n// simulate filling step 1 and clicking "Next"\nuserEvent.type(screen.getByPlaceholderText(/Title/), 'Test Vid');\nuserEvent.click(screen.getByText('Next'));\nexpect(screen.getByText('Preview')).toBeInTheDocument(); // moved to preview step                                                                                                                                                                                                                                                                                                                                                        |
| `src/components/app/video/wizard/steps/SettingsStep.tsx`                               | React Testing Library (Vitest) | Unit test for the Settings step of the upload wizard. Ensure that it validates inputs (e.g., title required, file size/type limits) and calls the provided `onNext` callback with the collected data when "Next" is clicked. Test with a valid file (under 10GB, correct format) and an invalid file (too large or wrong type) to see that an error message appears.                                                                                                                                                                                                                                                                                                            | render(<SettingsStep onNext={data => { collected = data; }} />);\nconst file = new File([Buffer.alloc(1024)], 'video.mp4', { type: 'video/mp4' });\nawait userEvent.upload(screen.getByLabelText(/File/), file);\nuserEvent.click(screen.getByText('Next'));\nexpect(collected.file).toBe(file); // onNext received file                                                                                                                                                                                                                                                                                                                                                                                              |
| `src/components/app/video/wizard/steps/PreviewStep.tsx`                                | React Testing Library (Vitest) | Unit test for the Preview step. It likely shows a preview of the video or the entered metadata. Ensure it renders the title/description that were provided from previous steps (pass props or context). If there's a "Submit" or "Upload" button on this step, simulate clicking it and ensure it triggers the final submission callback.                                                                                                                                                                                                                                                                                                                                       | render(<PreviewStep title="My Vid" description="Desc" onSubmit={onSubmit} />);\nexpect(screen.getByText('My Vid')).toBeInTheDocument();\nuserEvent.click(screen.getByRole('button', { name: /Upload/i }));\nexpect(onSubmit).toHaveBeenCalled();                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `supabase/migrations/* (video related)`                                                | **N/A**                        | _No runtime code to test._ However, consider an integration test in a staging environment to ensure migrations (e.g., added `deleted_at` field and RLS policies) function as expected. For instance, after deletion via API, ensure the video no longer appears in list queries due to RLS.                                                                                                                                                                                                                                                                                                                                                                                     | _N/A (schema validation via Supabase migration tests)._                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| `src/app/dashboard/posts/page.tsx`                                                     | Playwright (E2E)               | E2E test for the posts dashboard page. Verify that when a logged-in user visits the dashboard posts page, it displays a feed of posts (e.g. their own and followed content). Check that post cards are rendered with title and snippet, and that clicking on a post card navigates to the post detail page. Also ensure that if there are no posts, a friendly message is shown.                                                                                                                                                                                                                                                                                                | await page.goto('/dashboard/posts');\nawait expect(page.locator('.PostCard')).toHaveCount(>=1);\nawait page.click('.PostCard:first-child');\nawait expect(page).toHaveURL(/posts/); // navigated to detail                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| `src/app/(public)/posts/[slug]/page.tsx`                                               | Playwright (E2E)               | E2E test for public post detail page. Ensure that an unauthenticated user can view a post’s content. Verify the post title, body (rendered via the Lexical editor content), and any public comments are visible. If the post is in a collective or has reactions, those should be visible but interactive elements may prompt login. Also test that the SEO metadata (if any) appears in the page’s `<head>`.                                                                                                                                                                                                                                                                   | await page.goto('/posts/some-post-slug');\nawait expect(page.getByRole('heading', { name: 'Post Title' })).toBeVisible();\nawait expect(page.getByText('Post body content')).toBeVisible();                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| `src/app/posts/new/details/page.tsx`                                                   | Playwright (E2E)               | E2E test for creating a new post. Log in a user and navigate to the new post page. Use the editor to enter a title and content (simulate typing into the Lexical editor). Submit the form and verify that the user is redirected to the new post’s page or sees a success message. Ensure form validation works (e.g., cannot submit empty content) and that rate limiting (if any) does not allow excessive posts.                                                                                                                                                                                                                                                             | await page.goto('/posts/new/details');\nawait page.fill('input[name="title"]', 'My New Post');\nawait page.fill('.lexical-editor', 'This is the post body');\nawait page.click('button:has-text("Publish")');\nawait expect(page).toHaveURL(/posts/); // redirected to new post                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| `src/app/posts/[slug]/edit/details/page.tsx`                                           | Playwright (E2E)               | E2E test for editing a post. Log in as a user, navigate to one of their post’s edit page. Verify that the editor is pre-filled with the post’s current title and content. Modify the content, submit changes, and ensure the updates are reflected on the post detail page. Also test that a user cannot load this page for a post they do not own (should redirect or 403).                                                                                                                                                                                                                                                                                                    | await page.goto('/posts/my-post-slug/edit/details');\nawait expect(page.getByDisplayValue('Current Title')).toBeVisible();\nawait page.fill('.lexical-editor', 'Updated content');\nawait page.click('text=Save');\nawait expect(page).toHaveURL('/posts/my-post-slug');\nawait expect(page.getByText('Updated content')).toBeVisible();                                                                                                                                                                                                                                                                                                                                                                              |
| `src/lib/schemas/postSchemas.ts`                                                       | Vitest (unit)                  | Unit test for post data schemas/validation. Ensure that required fields (e.g., title) are enforced and that any computed defaults or transformations happen. For instance, test that extremely long titles or invalid tags are rejected according to schema rules. This prevents bad data from being accepted.                                                                                                                                                                                                                                                                                                                                                                  | expect(() => PostSchema.parse({ title: '' })).toThrow(); // empty title invalid\nconst valid = { title: 'Hello', content: 'World', tags: ['one', 'two'] };\nexpect(PostSchema.parse(valid)).toMatchObject({ title: 'Hello' });                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| `src/components/app/posts/molecules/PostCard.tsx`                                      | React Testing Library (Vitest) | Unit test for the PostCard component. Render a PostCard with sample post data and ensure it displays the title, author, and excerpt correctly. If it shows reaction counts or comment counts, verify those as well. Also simulate clicking on the card (if it's clickable) to ensure it calls a navigation function or callback.                                                                                                                                                                                                                                                                                                                                                | const post = { title: 'Example', author: { username: 'alice' }, excerpt: 'Lorem ipsum' };\nconst onClick = vi.fn();\nrender(<PostCard post={post} onClick={onClick} />);\nexpect(screen.getByText('Example')).toBeInTheDocument();\nuserEvent.click(screen.getByText('Example'));\nexpect(onClick).toHaveBeenCalled();                                                                                                                                                                                                                                                                                                                                                                                                |
| `src/components/app/posts/molecules/ArticleCard.tsx`                                   | React Testing Library (Vitest) | Unit test for ArticleCard (if separate from PostCard). Similar to PostCard, ensure it renders article-specific elements (maybe an image or reading time). If ArticleCard includes different styling or metadata, assert those. For example, check that a cover image is displayed if provided, and that clicking the card triggers navigation.                                                                                                                                                                                                                                                                                                                                  | render(<ArticleCard article={{ title: 'News', coverUrl: '/cover.jpg', snippet: 'Intro...' }} />);\nexpect(screen.getByText('News')).toBeVisible();\nexpect(screen.getByRole('img')).toHaveAttribute('src', '/cover.jpg');                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| `src/components/app/posts/molecules/VideoCard.tsx`                                     | React Testing Library (Vitest) | Unit test for VideoCard, which likely displays a video post in a feed. Ensure it shows a thumbnail or video preview, title, and maybe duration. If it has a play button overlay, check that it renders. Clicking it might navigate to the video page, so simulate that and verify behavior.                                                                                                                                                                                                                                                                                                                                                                                     | render(<VideoCard video={{ title: 'My Video', thumbnailUrl: '/thumb.png', duration: 120 }} />);\nexpect(screen.getByText('My Video')).toBeInTheDocument();\nconst thumb = screen.getByRole('img');\nexpect(thumb).toHaveAttribute('src', '/thumb.png');                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| `src/components/app/posts/molecules/PostCardHeader.tsx`                                | React Testing Library (Vitest) | Unit test for the header section of a PostCard (author info, timestamp, etc.). Provide props like author name, avatar, and timestamp, then ensure those render correctly (e.g., avatar image or initials, formatted date). Test that clicking on the author's name might navigate to their profile.                                                                                                                                                                                                                                                                                                                                                                             | const author = { username: 'bob', avatar_url: null };\nrender(<PostCardHeader author={author} date="2025-06-21T00:00:00Z" />);\nexpect(screen.getByText('@bob')).toBeInTheDocument();\nexpect(screen.getByText(/Jun 21, 2025/)).toBeTruthy();                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| `src/components/app/posts/molecules/PostCardFooter.tsx`                                | React Testing Library (Vitest) | Unit test for the footer of a PostCard (reactions, comments count, bookmark). Ensure that it displays the correct counts (e.g., "5 likes, 2 comments") given props. Simulate clicking the like button and ensure it triggers the ReactionButtons logic (which can be mocked or spied). Similarly, test that clicking the bookmark toggles its state (if applicable).                                                                                                                                                                                                                                                                                                            | render(<PostCardFooter likes={3} comments={1} onLike={onLike} onComment={onComment} />);\nexpect(screen.getByText('3')).toBeInTheDocument(); // likes count\nuserEvent.click(screen.getByLabelText('Like'));\nexpect(onLike).toHaveBeenCalled();                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `src/components/app/posts/molecules/BookmarkButton.tsx`                                | React Testing Library (Vitest) | Unit test for the bookmark toggle button. Verify that if the post is initially bookmarked vs not, the icon reflects the state (filled vs outline). Simulate a click and ensure it calls the provided handler or toggles state internally. If it triggers an API (like to save bookmark), mock that call.                                                                                                                                                                                                                                                                                                                                                                        | const handleToggle = vi.fn();\nrender(<BookmarkButton isBookmarked={false} onToggle={handleToggle} />);\nconst btn = screen.getByRole('button');\nexpect(btn).toHaveAttribute('aria-pressed', 'false');\nuserEvent.click(btn);\nexpect(handleToggle).toHaveBeenCalled();                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| `src/components/app/posts/organisms/PostFeed.tsx`                                      | React Testing Library (Vitest) | Unit test for the PostFeed component which renders a list of posts. Provide an array of post objects as props and ensure it renders a PostCard for each. Also test that if new posts are added (simulate prop change or internal state update), they appear. If it implements infinite scroll or pagination, simulate scrolling to bottom and ensure more posts load (which may involve mocking an intersection observer or scroll event).                                                                                                                                                                                                                                      | const posts = [{ id: 1, title: 'First' }, { id: 2, title: 'Second' }];\nrender(<PostFeed initialPosts={posts} />);\nexpect(screen.getByText('First')).toBeInTheDocument();\nexpect(screen.getByText('Second')).toBeInTheDocument();                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |
| `src/components/app/posts/collective-selection/CollectiveSelectionSummary.tsx`         | React Testing Library (Vitest) | Unit test for the UI that shows which collective a post will be shared to (or was shared to). If this component displays a collective name or icon for a chosen collective, ensure it renders correctly. Test that changing the selection (if interactive) updates the summary.                                                                                                                                                                                                                                                                                                                                                                                                 | render(<CollectiveSelectionSummary collective={{ name: 'Science' }} />);\nexpect(screen.getByText('Science')).toBeInTheDocument();                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| `src/components/app/posts/collective-selection/CollectiveValidationFeedback.tsx`       | React Testing Library (Vitest) | Unit test for the feedback message when posting to a collective. For example, if a user is not allowed to post (not a member), this might show an error. Provide different scenarios (allowed vs not allowed) via props and ensure the message text changes accordingly (e.g., “You must join this collective to post”).                                                                                                                                                                                                                                                                                                                                                        | render(<CollectiveValidationFeedback canPost={false} collectiveName="Science" />);\nexpect(screen.getByText(/must join Science to post/)).toBeVisible();                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| `src/lib/data-access/comment.repository.ts`                                            | Vitest (integration)           | Integration test for comment repository functions (polymorphic comment system). Test that adding a comment via the repository either calls the appropriate stored procedure or inserts correctly and returns a Comment object. Also verify that fetching comments by post or video returns the expected list, and that errors (e.g., invalid foreign key) yield undefined or empty results. This can be done with a stubbed supabase similar to other repositories.                                                                                                                                                                                                             | supabase.from = () => ({ select: () => ({ eq: () => ({ order: () => ({ error: null, data: [ { id: 'c1', content: 'hi' } ] }) }) }) });\nconst comments = await commentRepo.getByPostId('post1');\nexpect(comments[0].content).toBe('hi');                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |
| `src/components/ui/CommentsSkeleton.tsx`                                               | React Testing Library (Vitest) | Snapshot or structural test for the loading skeleton of comments. Simply render it and ensure the correct number of placeholder lines or shapes are present (e.g., if it shows 3 dummy comment bars, verify that count).                                                                                                                                                                                                                                                                                                                                                                                                                                                        | const { container } = render(<CommentsSkeleton />);\nexpect(container.querySelectorAll('.skeleton-line')).toHaveLength(3);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| `src/app/chat/page.tsx`                                                                | Playwright (E2E)               | E2E test for the chat page (likely a global chat or messages interface). Log in two users in different browser contexts; have User A send a message and ensure User B sees it in real-time (if using Supabase realtime). Verify that the chat UI scrolls appropriately, that sending an empty message is prevented, and that typing indication appears when one user is typing. This ensures the end-to-end chat functionality and security (only members of a conversation can load it).                                                                                                                                                                                       | await userA.page.goto('/chat');\nawait userB.page.goto('/chat');\nawait userA.page.fill('textarea', 'Hello');\nawait userA.page.keyboard.press('Enter');\nawait expect(userB.page.getByText('Hello')).toBeVisible();                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| `src/app/chat/layout.tsx`                                                              | React Testing Library (Vitest) | Unit test for the chat layout (likely containing sidebars for collectives/channels and a main chat area). Ensure that it renders its children (chat content) and the sidebar components. You can shallow-render to verify that `CollectiveIconsSidebar` and `CollectiveChannelsSidebar` appear, and that context providers (if any) wrap the content.                                                                                                                                                                                                                                                                                                                           | render(<ChatLayout><div>ChatContent</div></ChatLayout>);\nexpect(screen.getByText('ChatContent')).toBeInTheDocument();\n// Sidebar headings or icons present\nexpect(screen.getByLabelText('Channels')).toBeTruthy();                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| `src/app/api/chat/[conversationId]/message/route.ts`                                   | Supertest (integration)        | Integration test for sending a message in a conversation. Test that an authenticated user can POST a message to `/api/chat/:conversationId/message` and get a 201 with the created message (content, timestamp, etc.). Verify that if the user is not part of the conversation, the route returns 403. Also test input validation (e.g., empty message not allowed) returns 400.                                                                                                                                                                                                                                                                                                | await supertest(app).post('/api/chat/conv123/message').set('Authorization', userToken).send({ text: 'Hi' }).expect(201);\nawait supertest(app).post('/api/chat/conv123/message').set('Authorization', otherUserToken).send({ text: 'Hi' }).expect(403);                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| `src/components/chat/chat-panel.tsx`                                                   | React Testing Library (Vitest) | Integration test for the main chat panel UI. Render the ChatPanel with a list of messages and ensure it displays each message (text, sender). Simulate a user typing a new message into the input and pressing enter, and verify that `onSend` (prop or context action) is called with the message text. Also ensure that when a new message is added to props, the panel scrolls to show it (if the component manages scroll; you might spy on a scrollTo method).                                                                                                                                                                                                             | const messages = [{ id: 1, content: 'Hello', author: 'Alice' }];\nconst onSend = vi.fn();\nrender(<ChatPanel messages={messages} onSend={onSend} />);\nexpect(screen.getByText('Hello')).toBeVisible();\nawait userEvent.type(screen.getByPlaceholderText(/Type a message/), 'Hey{enter}');\nexpect(onSend).toHaveBeenCalledWith('Hey');                                                                                                                                                                                                                                                                                                                                                                              |
| `src/components/chat/message-input.tsx`                                                | React Testing Library (Vitest) | Unit test for the message input component. Ensure it calls the provided send handler when the user presses enter or clicks the send button. Also test that it respects disabled state (e.g., if sending is in progress or user is not allowed, the input is disabled).                                                                                                                                                                                                                                                                                                                                                                                                          | const onSend = vi.fn();\nrender(<MessageInput onSend={onSend} disabled={false} />);\nconst textbox = screen.getByRole('textbox');\nawait userEvent.type(textbox, 'Test message{enter}');\nexpect(onSend).toHaveBeenCalledWith('Test message');                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| `src/components/chat/message-edit-form.tsx`                                            | React Testing Library (Vitest) | Unit test for the message editing form. If a user can edit a previously sent message, this form likely shows the current text and has Save/Cancel. Test that the current text is populated, that editing it and pressing Save calls the update handler with new text, and that Cancel calls the cancel handler (and maybe resets text). Also verify that empty edits are not allowed (if applicable).                                                                                                                                                                                                                                                                           | const onSave = vi.fn();\nconst onCancel = vi.fn();\nrender(<MessageEditForm initialText="old" onSave={onSave} onCancel={onCancel} />);\nawait userEvent.clear(screen.getByDisplayValue('old'));\nawait userEvent.type(screen.getByRole('textbox'), 'edited');\nuserEvent.click(screen.getByText('Save'));\nexpect(onSave).toHaveBeenCalledWith('edited');                                                                                                                                                                                                                                                                                                                                                             |
| `src/components/chat/message-row.tsx`                                                  | React Testing Library (Vitest) | Unit test for individual chat message display. Ensure that it shows the message content and perhaps the sender name or avatar. If it differentiates between the current user’s messages and others (alignment or styling), provide props to render both cases and check that e.g. the current user’s message has a special class or alignment to the right.                                                                                                                                                                                                                                                                                                                     | const myMsg = { content: 'Hi', authorId: 'u1' };\nconst otherMsg = { content: 'Hello', authorId: 'u2', authorName: 'Bob' };\nrender(<><MessageRow message={myMsg} currentUserId="u1" /><MessageRow message={otherMsg} currentUserId="u1" /></>);\n// 'Hi' should be marked as self\nexpect(screen.getByText('Hi').closest('.my-message')).toBeTruthy();\n// 'Hello' should show sender name\nexpect(screen.getByText('Bob')).toBeInTheDocument();                                                                                                                                                                                                                                                                     |
| `src/components/chat/virtual-message-list.tsx`                                         | React Testing Library (Vitest) | Unit test for the virtualized message list (if using windowing for performance). This is more complex: you can simulate a list of many messages and ensure only a subset is in the DOM at a time. Scroll events might be simulated by adjusting a container scrollTop and triggering a resize/scroll. Verify that after scrolling, new messages come into view. Also ensure that the newest message is scrolled into view when added.                                                                                                                                                                                                                                           | const msgs = Array.from({ length: 50 }, (_, i) => ({ id: i, content: `Msg ${i}` }));\nconst { container } = render(<VirtualMessageList messages={msgs} />);\n// Initially, not all messages are rendered (virtualized)\nexpect(container.textContent).toContain('Msg 0');\nexpect(container.textContent).not.toContain('Msg 49');\n// Simulate scroll to bottom...\n _(continued)\_                                                                                                                                                                                                                                                                                                                                   |
| `src/components/chat/simple-message-list.tsx`                                          | React Testing Library (Vitest) | Unit test for a non-virtualized message list (if provided as a simpler alternative). Simply ensure that given a list of messages, it renders each one via MessageRow or similar. Also check that it scrolls to the bottom when new messages arrive (maybe spy on scroll or check last message is visible after update).                                                                                                                                                                                                                                                                                                                                                         | const msgs = ['Hi', 'Hello'];\nconst { rerender } = render(<SimpleMessageList messages={msgs.map((text,i)=>({ id: i, content: text}))} />);\nexpect(screen.getByText('Hi')).toBeInTheDocument();\n// Add a new message\nmsgs.push('Welcome');\nrerender(<SimpleMessageList messages={[...msgs].map((text,i)=>({ id: i, content: text}))} />);\nexpect(screen.getByText('Welcome')).toBeVisible();                                                                                                                                                                                                                                                                                                                     |
| `src/components/chat/typing-indicator.tsx`                                             | React Testing Library (Vitest) | Unit test for the typing indicator component. If it shows "User is typing..." or an animated ellipsis when someone is typing, ensure it renders correctly when active. Provide props like `active=true` and maybe a username, then check the text. Also verify that when not active, it renders nothing or is hidden.                                                                                                                                                                                                                                                                                                                                                           | const { rerender } = render(<TypingIndicator active={false} />);\nexpect(screen.queryByText(/typing/)).toBeNull();\nrerender(<TypingIndicator active={true} name="Alice" />);\nexpect(screen.getByText('Alice is typing...')).toBeInTheDocument();                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| `src/components/chat/collective-icons-sidebar.tsx`                                     | React Testing Library (Vitest) | Unit test for the sidebar listing collectives (perhaps as icons). Provide a list of collective objects (with name, icon URL or initials) that the user belongs to. Ensure the component renders an icon or link for each collective. Test that clicking an icon triggers navigation or selection of that collective’s chat (perhaps by checking a handler call).                                                                                                                                                                                                                                                                                                                | const collects = [{ id: 'c1', name: 'Alpha' }, { id: 'c2', name: 'Beta' }];\nconst onSelect = vi.fn();\nrender(<CollectiveIconsSidebar collectives={collects} onSelect={onSelect} />);\nexpect(screen.getByText('Alpha')).toBeVisible();\nuserEvent.click(screen.getByText('Beta'));\nexpect(onSelect).toHaveBeenCalledWith('c2');                                                                                                                                                                                                                                                                                                                                                                                    |
| `src/components/chat/collective-channels-sidebar.tsx`                                  | React Testing Library (Vitest) | Unit test for the channels list sidebar within a collective. Provide a list of channel objects (id, title, maybe unread count). Ensure that all channels are listed. If the component highlights the active channel, simulate selecting a channel and ensure the active style applies. Also test that clicking a channel triggers a callback to change channel.                                                                                                                                                                                                                                                                                                                 | const channels = [{ id: 'general', title: 'General' }, { id: 'random', title: 'Random' }];\nconst onSelect = vi.fn();\nrender(<CollectiveChannelsSidebar channels={channels} currentChannel="general" onSelect={onSelect} />);\nexpect(screen.getByText('General')).toHaveClass('active');\nuserEvent.click(screen.getByText('Random'));\nexpect(onSelect).toHaveBeenCalledWith('random');                                                                                                                                                                                                                                                                                                                            |
| `src/hooks/use-unread-messages.ts`                                                     | Vitest (unit)                  | Unit test for the custom hook tracking unread messages. Likely, this hook uses Supabase real-time or polling to update unread count. You can mock the underlying subscription (e.g., pretend some messages are marked read) and ensure the hook returns the correct count. Use React Testing Library’s `renderHook` to test it. For example, simulate receiving a new message event and verify the unread count increments.                                                                                                                                                                                                                                                     | const { result } = renderHook(() => useUnreadMessages('conv123', userId));\nact(() => {\n // simulate an event from Supabase\n triggerSupabaseEvent({ conversation_id: 'conv123' });\n});\nexpect(result.current).toBe(1);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| `src/lib/hooks/use-chat-v2.ts`                                                         | Vitest (unit)                  | Unit test for chat state management hook. Ensure that on initial load it fetches the conversation history (mock supabase or fetch call) and returns messages. Also test that sending a message via the hook adds to the state and perhaps calls the API. Use `renderHook` and simulate state updates by invoking the hook’s returned send function.                                                                                                                                                                                                                                                                                                                             | const fakeMessages = [{ id: 'm1', content: 'hi' }];\nvi.spyOn(apiClient, 'fetchMessages').mockResolvedValue(fakeMessages);\nconst { result, waitForNextUpdate } = renderHook(() => useChatV2('conv1'));\nawait waitForNextUpdate();\nexpect(result.current.messages).toEqual(fakeMessages);\nact(() => {\n result.current.sendMessage('hello');\n});\nexpect(apiClient.sendMessage).toHaveBeenCalledWith('conv1', 'hello');                                                                                                                                                                                                                                                                                           |
| `src/lib/hooks/use-chat-realtime.ts`                                                   | Vitest (unit)                  | Unit test for the realtime subscription hook for chat. Mock the Supabase realtime channel: have it call a listener callback when a new message event occurs. Verify the hook adds that message to its state or calls an update callback. Also ensure cleanup unsubscribes on unmount. Use a dummy Supabase channel object with jest mocks for `.on` and `.subscribe`.                                                                                                                                                                                                                                                                                                           | const channel = { on: vi.fn((event, cb) => { if(event==='postgres_changes'){ listener = cb; } return channel; }), subscribe: vi.fn(), unsubscribe: vi.fn() };\nvi.spyOn(supabase, 'channel').mockReturnValue(channel);\nconst { unmount } = renderHook(() => useChatRealtime('conv1'));\nexpect(channel.subscribe).toHaveBeenCalled();\nact(() => { listener({ new: { content: 'hi' } }); });\n// expect state update or external callback triggered\nunmount(); expect(channel.unsubscribe).toHaveBeenCalled();                                                                                                                                                                                                      |
| `src/lib/chat/realtime-adapter.ts`                                                     | Vitest (unit)                  | Unit test for an adapter that bridges Supabase realtime to the app. This might encapsulate subscribing to channels or mapping events. Test that calling functions like `joinChannel(conversationId)` returns a subscription and that incoming events are properly parsed (e.g., new message records turned into app-friendly objects). Use a mocked Supabase client/channel to verify method calls.                                                                                                                                                                                                                                                                             | const channelMock = { on: vi.fn().mockReturnThis(), subscribe: vi.fn() };\nvi.spyOn(client, 'channel').mockReturnValue(channelMock);\njoinChannel('conv1');\nexpect(client.channel).toHaveBeenCalledWith('conversation:conv1');\nexpect(channelMock.subscribe).toHaveBeenCalled();                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| `src/lib/chat/realtime-service.ts`                                                     | Vitest (unit)                  | Unit test for a higher-level realtime service (perhaps managing multiple channels or events). Ensure that subscribing to a conversation or collective channel triggers the underlying adapter and that it handles reconnection or multiple listeners properly. Simulate multiple calls and ensure no duplicate subscriptions. This might involve internal state, so you can inspect that or spy on adapter calls.                                                                                                                                                                                                                                                               | const adapter = { subscribeToConversation: vi.fn() };\nRealtimeService.init(adapter);\nRealtimeService.joinConversation('conv123');\nexpect(adapter.subscribeToConversation).toHaveBeenCalledWith('conv123');\n// calling again doesn't double-subscribe\nRealtimeService.joinConversation('conv123');\nexpect(adapter.subscribeToConversation).toHaveBeenCalledTimes(1);                                                                                                                                                                                                                                                                                                                                             |
| `src/hooks/collectives/useCollectiveData.ts`                                           | Vitest (unit)                  | Unit test for fetching or managing collective data. Possibly this hook loads info about a specific collective (members, posts, etc.). Mock the data fetch (via Supabase or fetch) to return known data, then ensure the hook outputs that data (name, description, membership status). Also test loading and error states: have the fetch reject and ensure the hook sets an error flag.                                                                                                                                                                                                                                                                                        | vi.spyOn(api, 'getCollective').mockResolvedValue({ name: 'Test Collective', memberCount: 5 });\nconst { result, waitForNextUpdate } = renderHook(() => useCollectiveData('collectiveId'));\nawait waitForNextUpdate();\nexpect(result.current.collective.name).toBe('Test Collective');                                                                                                                                                                                                                                                                                                                                                                                                                               |
| `src/app/(public)/collectives/[slug]/page.tsx`                                         | Playwright (E2E)               | E2E test for a public collective page. Verify that it displays collective details (name, description) and a list of content or members if applicable. If users can join from this page, simulate clicking a "Join Collective" button and ensure it prompts login or performs the join (depending on auth). Also test that if the slug is invalid, a 404 or redirect occurs.                                                                                                                                                                                                                                                                                                     | await page.goto('/collectives/science');\nawait expect(page.getByRole('heading', { name: /Science/ })).toBeVisible();\nawait page.click('text=Join Collective');\n// if not logged in, expect redirect to sign-in\nawait expect(page).toHaveURL('/sign-in?redirect=%2Fcollectives%2Fscience');                                                                                                                                                                                                                                                                                                                                                                                                                        |
| `src/app/dashboard/collectives/page.tsx`                                               | Playwright (E2E)               | E2E test for the user's collectives dashboard. After login, go to this page and verify it lists collectives the user owns or is a member of. Ensure that each listed collective shows relevant info (name, role, perhaps unread posts count). Test navigation from this page: clicking a collective takes you to its management or detail page. Also ensure that if user is not in any collective, an appropriate message is shown.                                                                                                                                                                                                                                             | await page.goto('/dashboard/collectives');\nif(await page.$('text=No collectives') !== null) {\n // user has no collectives\n await expect(page.getByText('No collectives')).toBeVisible();\n} else {\n await expect(page.locator('.CollectiveCard')).toHaveCount(>=1);\n}                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| `src/app/dashboard/collectives/[collectiveId]/settings/EditCollectiveSettingsForm.tsx` | React Testing Library (Vitest) | Unit test for the collective settings form. Render the form with a sample collective settings object (name, description, privacy settings, etc.). Ensure that the form fields are populated with current values, and that submitting with changes calls the update action. Validate that invalid inputs (e.g. name too short) show errors. You can mock the `updateCollectiveSettings` server action to test that it would be called with the correct data.                                                                                                                                                                                                                     | render(<EditCollectiveSettingsForm collective={{ name: 'Test', description: 'Desc' }} />);\nawait userEvent.type(screen.getByLabelText(/Name/), 'Updated');\nuserEvent.click(screen.getByText('Save'));\n// assume an onSave mock was provided\nexpect(onSave).toHaveBeenCalledWith(expect.objectContaining({ name: 'Updated' }));                                                                                                                                                                                                                                                                                                                                                                                    |
| `src/app/api/collectives/[collectiveId]/channels/route.ts`                             | Jest/Vitest (integration)      | Integration test for collective channels listing/creation API. Use the pattern from existing tests to verify: (1) 401 if no auth, (2) 403 if user is not a member for GET or not an admin for POST, (3) successful GET returns channel list, (4) successful POST creates a new channel (201 status and returns new channel ID), (5) error in creation returns 500 with error message. These tests should mock `createServerSupabaseClient` and the `.from(...)` queries as in the repository’s test.                                                                                                                                                                            | supabase.auth.getUser.mockResolvedValue({ data: { user: { id: 'u1' } }, error: null });\nsupabase.from.mockReturnValueOnce(new Query({ role: 'member' }, null));\nconst res = await GET(new Request('http://...'), { params: { collectiveId: 'col1' } });\nexpect(res.status).toBe(403); // user not admin for creation\n// ... (similar for other scenarios)                                                                                                                                                                                                                                                                                                                                                         |
| `src/app/api/collectives/[collectiveId]/channels/[channelId]/join/route.ts`            | Supertest (integration)        | Integration test for joining a specific channel. If this endpoint is to subscribe the current user to a channel, test that a valid member of the collective can join (expect 204 or similar), and that a non-member gets 403. Also ensure idempotence (joining twice doesn’t error). You might verify via a follow-up query that the membership was created (or mock the DB insert and check it was called).                                                                                                                                                                                                                                                                    | await supertest(app).post('/api/collectives/col1/channels/ch123/join').set('Authorization', memberToken).expect(204);\nawait supertest(app).post('/api/collectives/col1/channels/ch123/join').set('Authorization', nonMemberToken).expect(403);                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| `src/app/api/collectives/[collectiveId]/members/auto-join-channels/route.ts`           | Vitest (integration)           | Integration test for the auto-join logic after a user joins a collective. Simulate a request (perhaps this is called internally) with a new member. Verify it subscribes the user to default channels. This might involve mocking supabase to return some default channel list and checking that insertions are made for each. Ensure that if a user is already in channels, it handles gracefully (no duplicates).                                                                                                                                                                                                                                                             | supabase.from.mockReturnValueOnce({ select: () => ({ eq: () => ({ error: null, data: [{ id: 'ch1' }] }) }) });\n// channels to auto-join\nsupabase.from.mockReturnValueOnce({ insert: () => ({ error: null }) });\nconst res = await POST(new Request('http://...'), { params: { collectiveId: 'col1' } });\nexpect(res.status).toBe(204);\nexpect(supabase.from().insert).toHaveBeenCalled();                                                                                                                                                                                                                                                                                                                        |
| `src/app/api/collectives/[collectiveId]/plans/route.ts`                                | Supertest (integration)        | Integration test for collective plans (likely retrieving pricing plans or subscription info). Ensure that an authenticated collective owner can GET their Stripe plan details, and that unauthorized users cannot. If this endpoint also allows updates (POST/PUT), test that with valid data it updates and invalid data is rejected. Mock external calls (e.g., to Stripe) if needed.                                                                                                                                                                                                                                                                                         | await supertest(app).get('/api/collectives/col1/plans').set('Authorization', ownerToken).expect(200);\nawait supertest(app).get('/api/collectives/col1/plans').set('Authorization', memberToken).expect(403);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| `src/app/api/collectives/[collectiveId]/stripe-onboard/route.ts`                       | Supertest (integration)        | Integration test for Stripe onboarding link creation. Simulate a POST request by a collective owner to this route. Mock the Stripe SDK call that creates an account link, returning a test URL. Verify that the response contains the onboarding URL and status 200. Test that non-owners get 403. Also, if required, test that missing Stripe account (if collective not set up) yields appropriate error.                                                                                                                                                                                                                                                                     | stripe.accounts.createLink = vi.fn().mockResolvedValue({ url: '[https://stripe.onboard.test](https://stripe.onboard.test)' });\nawait supertest(app).post('/api/collectives/col1/stripe-onboard').set('Authorization', ownerToken).expect(200).then(res => {\n expect(res.body.url).toContain('stripe.onboard.test');\n});\nawait supertest(app).post('/api/collectives/col1/stripe-onboard').set('Authorization', nonOwnerToken).expect(403);                                                                                                                                                                                                                                                                        |
| `src/lib/stripe.ts`                                                                    | Vitest (unit)                  | Unit test for Stripe utility module. This likely initializes the Stripe client or provides helper functions for payments. Test that `getStripe()` returns a Stripe instance (you might spy on the Stripe constructor to ensure it’s called with the secret key). If there are helper functions (e.g., to create checkout sessions), mock Stripe methods and ensure our function passes correct parameters and handles errors properly.                                                                                                                                                                                                                                          | process.env.STRIPE_SECRET_KEY = 'sk_test_123';\nconst stripeClient = getStripe();\nexpect(stripeClient).toBeDefined(); // Stripe initialized\n// If a createCheckoutSession util exists:\nstripeClient.checkout.sessions.create = vi.fn().mockResolvedValue({ url: '[http://checkout](http://checkout)' });\nconst url = await createCheckoutSession('plan_ABC');\nexpect(url).toBe('http://checkout');\nexpect(stripeClient.checkout.sessions.create).toHaveBeenCalledWith(expect.objectContaining({ price: 'plan_ABC' }));                                                                                                                                                                                          |
| `src/app/api/stripe-webhook/route.ts`                                                  | Vitest (integration)           | Integration test for Stripe webhook handling. Simulate a Stripe webhook event POST. Use Stripe’s library (or a stub) to construct a signed event. For example, generate a fake `checkout.session.completed` event payload and use a test signing secret to compute a signature header. Send this to the route and expect a 200 response. Also simulate an invalid signature to ensure it returns 400 (not processed). Additionally, if the webhook logic updates user subscriptions, verify that side effect (perhaps by checking a user’s record via supabase stub).                                                                                                           | const event = { type: 'checkout.session.completed', data: { object: {/_..._/} } };\nconst sigHeader = stripe.webhooks.generateTestHeaderString({ payload: JSON.stringify(event), secret: process.env.STRIPE_WEBHOOK_SECRET });\nconst res = await POST(new Request('[http://.../api/stripe-webhook](http://.../api/stripe-webhook)', {\n method: 'POST', body: JSON.stringify(event), headers: { 'stripe-signature': sigHeader }\n}));\nexpect(res.status).toBe(200);\n// Invalid signature:\nconst res2 = await POST(new Request('[http://.../api/stripe-webhook](http://.../api/stripe-webhook)', {\n body: JSON.stringify(event), headers: { 'stripe-signature': 'bad_sig' }\n}));\nexpect(res2.status).toBe(400); |
| `src/app/actions/collectiveActions.ts`                                                 | Vitest (unit)                  | Unit tests for server actions related to collectives (invite/remove members, update settings, etc.). Use dependency injection or module mocking to simulate supabase and Stripe as needed. For example, test `inviteUserToCollective`: if current user is not owner, it returns an error; if email is invalid, returns field error; if all checks pass, it inserts the member and returns success. Mock `createServerSupabaseClient()` to return an object with stubbed `auth.getUser` and query methods. Similarly, test `removeUserFromCollective` for permission checks and success removal. Ensure that after successful actions, `revalidatePath` is called if applicable. | vi.mock('@/lib/supabase/server', () => ({ createServerSupabaseClient: () => supabaseStub }));\n// Case: user not owner\nsupabaseStub.auth.getUser.mockResolvedValue({ data: { user: { id: 'u2' } }, error: null });\nsupabaseStub.from.mockReturnValue({ select: () => ({ single: async () => ({ data: null, error: { message: '...'} }) }) });\nconst result = await inviteUserToCollective('col1', '[invitee@example.com](mailto:invitee@example.com)', 'member');\nexpect(result.success).toBe(false);\nexpect(result.error).toMatch(/not the owner/);                                                                                                                                                             |
| `src/app/actions/userActions.ts`                                                       | Vitest (unit)                  | Unit tests for server actions related to user profile (update profile, avatar upload, account deletion, etc.). For `updateUserProfile`, test that it validates input (e.g. username length) and updates the `users` table via supabase. Mock `supabaseAdmin` for file uploads if needed and `createServerSupabaseClient` for DB updates. For `deleteUserAccount`, stub `supabaseAdmin.auth.admin.deleteUser` to simulate success and error, and ensure it returns the correct success boolean and logs metrics. Also test rate-limiting: call updateProfile more than allowed times and ensure it returns an error after the threshold.                                         | supabaseStub.auth.getUser.mockResolvedValue({ data: { user: { id: 'u1' } }, error: null });\n// simulate too many profile updates\nfor(let i=0;i<20;i++){ await updateUserProfile({ username: 'user'+i }); }\nconst res = await updateUserProfile({ username: 'excess' });\nexpect(res.success).toBe(false);\nexpect(res.error).toMatch(/rate limit/i);\n// Delete account\nsupabaseAdmin.auth.admin.deleteUser = vi.fn().mockResolvedValue({});\nconst delRes = await deleteUserAccount();\nexpect(delRes.success).toBe(true);                                                                                                                                                                                       |
| `src/app/actions/subscriptionActions.ts`                                               | Vitest (unit)                  | Unit tests for any subscription-related server actions (e.g., upgrading a user’s plan, canceling subscription). Mock Stripe API calls: for example, if there’s a `createSubscription` action, stub `stripe.subscriptions.create` to return a subscription ID. Ensure the action saves relevant info to Supabase (perhaps updating the user’s profile or a subscription table). Test that invalid plans or Stripe errors result in an appropriate error message.                                                                                                                                                                                                                 | stripe.subscriptions.create = vi.fn().mockResolvedValue({ id: 'sub_123' });\nconst res = await subscribeToPremium('price_gold');\nexpect(res.success).toBe(true);\nexpect(stripe.subscriptions.create).toHaveBeenCalledWith(expect.objectContaining({ price: 'price_gold' }));                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| `src/lib/supabase/server.ts`                                                           | Vitest (unit)                  | Unit test for the server-side Supabase client initializer. Ensure that calling `createServerSupabaseClient()` with mock request/response cookies returns a Supabase client instance. You can test that it properly reads cookies (e.g., provide a fake request with `sb-access-token` cookie and ensure the client has that session). This mostly verifies integration with NextRequest cookies.                                                                                                                                                                                                                                                                                | const req = { cookies: { get: (name: string) => name==='sb-access-token' ? { value: 'testtoken' } : undefined } };\nconst res = { cookies: { set: vi.fn() } };\nconst supabase = createServerSupabaseClient(req as any, res as any);\nexpect(supabase).toBeDefined();\n// no error thrown with missing env\n                                                                                                                                                                                                                                                                                                                                                                                                          |
| `src/lib/supabase/browser.ts`                                                          | Vitest (unit)                  | Unit test for the browser-side Supabase client. This likely just creates a singleton client with anon key. Test that it initializes with the expected URL and anon key from environment. Also, if any caching or single-instance behavior is intended, ensure that repeated imports return the same client (could test by comparing two calls).                                                                                                                                                                                                                                                                                                                                 | process.env.NEXT_PUBLIC_SUPABASE_URL = 'https://xyz.supabase.co';\nprocess.env.NEXT_PUBLIC_SUPABASE_ANON_KEY = 'anon-key';\nconst client1 = supabase; // import from browser.ts\nconst { createClient } = require('@supabase/supabase-js');\nexpect(createClient).toHaveBeenCalledWith(expect.stringContaining('supabase.co'), 'anon-key');                                                                                                                                                                                                                                                                                                                                                                           |
| `src/lib/supabase/request-scoped.ts`                                                   | Vitest (unit)                  | Unit test to ensure a fresh Supabase client per request if that’s the intention. Likely similar to server, it might create a client with given cookies for each request. Test that calling it twice yields distinct client instances (if needed), and that it picks up the auth cookies correctly each time.                                                                                                                                                                                                                                                                                                                                                                    | const clientA = createRequestClient(reqA);\nconst clientB = createRequestClient(reqB);\nexpect(clientA).not.toBe(clientB); // new client per request                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| `src/lib/supabase/singleton-client.ts`                                                 | Vitest (unit)                  | Unit test to ensure the singleton Supabase client (if used to avoid multiple instances). Verify that calling initialization multiple times does not create new clients. You can spy on `createClient` from Supabase JS and ensure it's only called once. Also test that the singleton client is ready to use (e.g., can call `.from` without error).                                                                                                                                                                                                                                                                                                                            | const c1 = getSupabaseClient();\nconst c2 = getSupabaseClient();\nexpect(c1).toBe(c2);\nexpect(createClient).toHaveBeenCalledTimes(1);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
| `middleware.ts`                                                                        | Vitest (integration)           | Integration test for Next.js middleware handling auth and redirects. Using a simulated NextRequest, test that protected routes without a session cause a redirect to `/sign-in` with `purge=1`, and that accessing `/sign-in` with a valid session redirects to `/dashboard`. Also test the vanity URL rewrite: e.g., request `/@testuser` and verify NextResponse rewrites to `/profile/testuser`. This can be done by creating a dummy NextRequest and inspecting the NextResponse.                                                                                                                                                                                           | const req = new NextRequest('[http://localhost/@myuser');\nconst](<http://localhost/@myuser');%5Cnconst>) res = await middleware(req);\nexpect(res.status).toBeUndefined(); // should be a rewrite, not an error\nexpect(res.headers.get('x-middleware-rewrite')                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `src/lib/utils.ts`                                                                     | Vitest (unit)                  | Unit tests for general utilities. For example, if there are functions to format dates, sanitize inputs, or generate IDs, test those with various inputs. Ensure edge cases are handled (like empty or null inputs). Each utility function should have corresponding tests verifying correct output.                                                                                                                                                                                                                                                                                                                                                                             | expect(formatDate('2025-06-21T00:00:00Z')).toBe('June 21, 2025');\nexpect(sanitizeHtml('alert(1)Hi')).toBe('Hi');                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| `src/lib/utils/avatar.ts`                                                              | Vitest (unit)                  | Unit test for avatar-related utilities. Likely includes generating filenames and validating file types. Test `generateUniqueAvatarFilename` produces unique strings for given userIDs (perhaps using regex to match the pattern). Test `validateFileType` by passing in a dummy File with specific bytes and ensure it detects correct MIME or rejects unknown types.                                                                                                                                                                                                                                                                                                           | const file = new File([new Uint8Array([0xFF,0xD8,0xFF])], 'photo.jpg', { type: 'image/jpeg' });\nconst result = await validateFileType(file);\nexpect(result.valid).toBe(true);\nconst badFile = new File([new Uint8Array([0x00,0x01])], 'file.bin', { type: 'application/octet-stream' });\nexpect((await validateFileType(badFile)).valid).toBe(false);                                                                                                                                                                                                                                                                                                                                                             |
| `src/lib/utils/mux-signed-urls.ts`                                                     | Vitest (unit)                  | Unit test for Mux signed URL generation. If this module creates JWT tokens for Mux playback, test that calling the function returns a string token. You can decode the token (with a JWT library) to verify it contains expected claims (e.g., expiration ~1 hour, correct video playback ID). Also test that invalid inputs (like missing signing key) throw errors to ensure security.                                                                                                                                                                                                                                                                                        | process.env.MUX_SIGNING_SECRET = TEST_PRIVATE_KEY;\nconst token = createSignedPlaybackToken('playbackId123', 'viewerId456');\nexpect(typeof token).toBe('string');\n// decode token to inspect claims\nconst payload = decodeMuxToken(token);\nexpect(payload.exp).toBeGreaterThan(Date.now()/1000); // ~1 hour later                                                                                                                                                                                                                                                                                                                                                                                                 |
| `src/lib/constants/*`                                                                  | **N/A**                        | Constants (e.g., `chat.ts`, `post-editor.ts`, `notification.ts`) typically don’t need tests since they have no logic. However, you can include a trivial check to ensure the objects are defined. The main point is to ensure consistency, not behavior.                                                                                                                                                                                                                                                                                                                                                                                                                        | _N/A_                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| `src/components/ui/avatar.tsx`                                                         | React Testing Library (Vitest) | Unit test for Avatar component. Provide props for an image URL and for fallback (like user initials). Ensure that if an image URL is given, it renders an `<img>` with that source. If not, it shows the initials of the user’s name. Also test styling or size props if any.                                                                                                                                                                                                                                                                                                                                                                                                   | render(<Avatar name="Alice Doe" src={null} />);\nexpect(screen.getByText('AD')).toBeInTheDocument();\nrender(<Avatar name="Bob" src="/bob.png" />);\nconst img = screen.getByRole('img');\nexpect(img).toHaveAttribute('src', '/bob.png');                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| `src/components/ui/dropdown-menu.tsx`                                                  | React Testing Library (Vitest) | Unit test for the DropdownMenu component (likely a wrapper around Radix menu). Ensure that clicking the trigger opens the menu and displays all options. Use `userEvent.click` on the trigger and then verify the menu items are present. Simulate selecting an item and ensure the onSelect callback fires with the right value.                                                                                                                                                                                                                                                                                                                                               | render(<DropdownMenu options={['One','Two']} onSelect={onSelect} />);\nuserEvent.click(screen.getByRole('button'));\nexpect(screen.getByText('One')).toBeVisible();\nuserEvent.click(screen.getByText('Two'));\nexpect(onSelect).toHaveBeenCalledWith('Two');                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| `src/components/ui/radio-group.tsx`                                                    | React Testing Library (Vitest) | Unit test for RadioGroup component. Provide a list of options and a controlled selected value. Ensure it renders a radio input for each option, with the correct one checked. Simulate clicking a different option and verify the onChange handler is called with the new value.                                                                                                                                                                                                                                                                                                                                                                                                | render(<RadioGroup name="role" options={['User','Admin']} value="User" onChange={onChange} />);\nexpect(screen.getByLabelText('User')).toBeChecked();\nuserEvent.click(screen.getByLabelText('Admin'));\nexpect(onChange).toHaveBeenCalledWith('Admin');                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| `src/components/ui/select.tsx`                                                         | React Testing Library (Vitest) | Unit test for custom Select component. Ensure that it shows the selected option and that clicking it opens a dropdown of choices. Simulate selecting an option from the dropdown and verify the onChange gets the new value. Also ensure keyboard navigation (if supported) works: e.g., press ArrowDown + Enter to select.                                                                                                                                                                                                                                                                                                                                                     | render(<Select options={['Red','Blue']} value="Red" onChange={onChange} />);\nuserEvent.click(screen.getByText('Red'));\nexpect(screen.getByText('Blue')).toBeVisible();\nuserEvent.click(screen.getByText('Blue'));\nexpect(onChange).toHaveBeenCalledWith('Blue');                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| `src/components/ui/switch.tsx`                                                         | React Testing Library (Vitest) | Unit test for a toggle switch component. Ensure it reflects the `checked` state (on/off). Simulate clicking it and verify the onChange fires with the toggled value. Also test that it’s accessible (has role="checkbox" or similar and `aria-checked`).                                                                                                                                                                                                                                                                                                                                                                                                                        | render(<Switch checked={false} onCheckedChange={onChange} />);\nconst toggle = screen.getByRole('checkbox');\nexpect(toggle).toHaveAttribute('aria-checked', 'false');\nuserEvent.click(toggle);\nexpect(onChange).toHaveBeenCalledWith(true);                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| `src/components/ui/tabs.tsx`                                                           | React Testing Library (Vitest) | Unit test for Tabs component. Provide tab labels and content panels. Ensure the first tab is active by default (unless specified otherwise). Simulate clicking a different tab label and verify that the corresponding content is now visible and the previous is hidden. Also ensure the active tab gets an active style or attribute.                                                                                                                                                                                                                                                                                                                                         | render(<Tabs tabs={['Tab1','Tab2']} initialActive="Tab1"><div title="Tab1">Content1</div><div title="Tab2">Content2</div></Tabs>);\nexpect(screen.getByText('Content1')).toBeVisible();\nuserEvent.click(screen.getByText('Tab2'));\nexpect(screen.getByText('Content2')).toBeVisible();\nexpect(screen.queryByText('Content1')).not.toBeVisible();                                                                                                                                                                                                                                                                                                                                                                   |
| `src/components/ui/tooltip.tsx`                                                        | React Testing Library (Vitest) | Unit test for Tooltip component. Likely uses a hover or focus to show a tooltip message. Simulate hovering over the trigger element (possibly by firing `mouseOver`) and verify the tooltip text appears. Simulate mouseOut and ensure the tooltip disappears. Also test focus/blur for accessibility (tab to the element shows tooltip).                                                                                                                                                                                                                                                                                                                                       | render(<Tooltip content="Hello"><button>Hover me</button></Tooltip>);\nuserEvent.hover(screen.getByText('Hover me'));\nexpect(screen.getByText('Hello')).toBeVisible();\nuserEvent.unhover(screen.getByText('Hover me'));\nexpect(screen.queryByText('Hello')).toBeNull();                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| `src/components/editor/PostEditor.tsx`                                                 | Playwright (E2E)               | End-to-end-like test for the rich text editor. In a browser context (or jsdom if possible), simulate user actions: typing text, applying bold/italic (maybe by clicking toolbar buttons or using keyboard shortcuts), inserting a link or image if supported. Then ensure the editor’s output (maybe an onChange or the rendered preview) matches the expected HTML or text with formatting. Since Lexical is complex, focus on a couple of representative behaviors (typing text appears, bold button toggles bold format).                                                                                                                                                    | await page.click('.lexical-editor');\nawait page.keyboard.type('Hello ');\nawait page.click('button[aria-label="Bold"]');\nawait page.keyboard.type('World');\n// Expect 'World' to be bold in the output (could inspect editor state or DOM)                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| `src/components/editor/EditorLayout.tsx`                                               | React Testing Library (Vitest) | Unit test for the editor page layout. It might combine PostEditor and a sidebar or toolbar. Ensure that it renders the editor and any side components (like SEOSettingsDrawer if present). If it provides context (like a store for editor state), you can test that toggling a setting (like a SEO checkbox) updates the state by checking a context value or store directly.                                                                                                                                                                                                                                                                                                  | render(<EditorLayout />);\n// Assuming EditorLayout renders PostEditor and maybe a toolbar\nexpect(screen.getByText('Post Title')).toBeInTheDocument(); // placeholder or label in editor\nexpect(screen.getByText('SEO Settings')).toBeInTheDocument(); // side drawer trigger                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| `src/components/editor/LexicalOptimizedEditor.tsx`                                     | React Testing Library (Vitest) | Unit test for the Lexical editor component (optimized version). Since Lexical manages internal state, the test can verify that the component mounts without error with given initial content. If there are custom nodes or plugins, ensure they register (e.g., if the editor should display a mention or hashtag differently, provide initial content containing those and verify the DOM has the specialized element).                                                                                                                                                                                                                                                        | render(<LexicalOptimizedEditor content="Hello" />);\nexpect(screen.getByText('Hello')).toBeInTheDocument();                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| `src/components/editor/plugins/MarkdownTransformers/index.ts`                          | Vitest (unit)                  | Unit test for the Markdown transformers plugin. Likely it converts Lexical content to/from Markdown. Provide a sample Lexical state (or plain text) and ensure the transformer outputs the expected Markdown string, and vice versa. For example, test that a heading node becomes "# Heading" and a bold text becomes "**bold**". Use the plugin’s export functions directly if available.                                                                                                                                                                                                                                                                                     | const md = exportMarkdown(editorState); // assume editorState has a heading 'Test'\nexpect(md).toContain('# Test');\nconst newState = importMarkdown('**Bold**');\nexpect(newState.toText()).toContain('Bold'); // and Bold is marked strong in state                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| `src/components/editor/SEOSettingsDrawer.tsx`                                          | React Testing Library (Vitest) | Unit test for SEO settings UI in the editor. Ensure that it shows fields like meta title, description, and that toggling it open/closed works (maybe via a button in the editor layout). Enter text in the meta fields and ensure it calls an onChange handler or updates context/store. If there's a character count limit, test that it displays the remaining count and prevents exceeding max length.                                                                                                                                                                                                                                                                       | render(<SEOSettingsDrawer isOpen={true} settings={{ metaTitle: '', metaDescription: '' }} onChange={onChange} />);\nuserEvent.type(screen.getByLabelText(/Meta Title/), 'My Title');\nexpect(onChange).toHaveBeenCalledWith(expect.objectContaining({ metaTitle: 'My Title' }));                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| `src/lib/hooks/use-post-editor.ts`                                                     | Vitest (unit)                  | Unit test for the hook managing post editor state. It likely provides state for title, content, tags, etc., and functions to update them. Test that initial state is correct (e.g., empty or provided initial values), that calling the update functions changes the state accordingly (you might need to call them inside an `act` in a `renderHook` test), and that submitting via the hook calls the server action or API with assembled post data. Also test side effects like auto-saving (maybe using fake timers to simulate debounce and ensuring the save is called after delay).                                                                                      | const { result } = renderHook(() => usePostEditor(initialData));\nact(() => { result.current.updateTitle('New Title'); });\nexpect(result.current.title).toBe('New Title');\n// simulate submit\nresult.current.savePost();\nexpect(publishPostAction).toHaveBeenCalledWith(expect.objectContaining({ title: 'New Title' }));                                                                                                                                                                                                                                                                                                                                                                                         |
| `src/lib/stores/post-editor-store.ts`                                                  | Vitest (unit)                  | Unit test for a Zustand or Redux store managing editor state (if used). Import the store and use its API to set and get state. For example, call `setTitle('X')` and then verify `getState().title === 'X'`. Also test that resetting the store clears all fields, and that updating one field doesn’t wipe others. If the store has side-effects (like persisting to localStorage), you can mock `localStorage` and ensure it’s called.                                                                                                                                                                                                                                        | postEditorStore.setState({ title: 'Test' });\nexpect(postEditorStore.getState().title).toBe('Test');\npostEditorStore.getState().reset();\nexpect(postEditorStore.getState().title).toBe('');                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |
| `src/types/*`                                                                          | **N/A**                        | Typescript type definition files (e.g., `supabase.ts`, `notifications.ts`, etc.) do not require testing as they contain no executable code. Just ensure they align with the actual API by using them in tests of related modules (type-checking is handled by TS itself).                                                                                                                                                                                                                                                                                                                                                                                                       | _N/A_                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |
| `src/lib/notifications/service.ts`                                                     | Vitest (unit)                  | Unit test for the server-side notifications service. This likely includes functions to create notifications (e.g., when someone likes a post, create a notification record). Mock the Supabase client to simulate inserting into a `notifications` table and ensure the function returns success or the created object. Also test any filtering logic (for example, not notifying a user about their own action).                                                                                                                                                                                                                                                               | supabase.from.mockReturnValue({ insert: () => ({ select: () => ({ single: async () => ({ data: { id: 'n1' }, error: null }) }) }) });\nconst note = await createNotification('u2', 'u1', 'LIKE_POST', { postId: 'p1' });\nexpect(note?.id).toBe('n1');\nexpect(supabase.from).toHaveBeenCalledWith('notifications');                                                                                                                                                                                                                                                                                                                                                                                                  |
| `src/lib/notifications/client-service.ts`                                              | Vitest (unit)                  | Unit test for client-side notification handling. Possibly it fetches notifications for the current user or marks them as read. Test that `fetchNotifications()` (if present) calls the API or supabase and returns a list of notifications. Mock the network response to include a couple of notifications and ensure the function filters or sorts them as expected. Also test `markAsRead` if available: that it updates the specific notification’s status.                                                                                                                                                                                                                  | global.fetch = vi.fn().mockResolvedValue({ ok: true, json: async () => ({ data: [ { id: 'n1', read: false } ] }) });\nconst notes = await clientService.fetchNotifications();\nexpect(notes[0].id).toBe('n1');\nawait clientService.markAsRead('n1');\n// ensure API called to update notification\nexpect(fetch).toHaveBeenCalledWith(expect.stringContaining('/notifications'), expect.any(Object));                                                                                                                                                                                                                                                                                                                |
| `src/components/notifications/NotificationItem.tsx`                                    | React Testing Library (Vitest) | Unit test for individual notification item display. Provide a notification object (type, message, read status) as prop and ensure it renders the message and perhaps an icon based on type. If clicking the item should mark it read or navigate, simulate that and verify the behavior (e.g., `onClick` called or `markAsRead` function from context invoked). Also check that unread notifications might have a bold style or indicator.                                                                                                                                                                                                                                      | const notification = { id: 'n1', type: 'COMMENT', message: 'Alice commented', read: false };\nconst onClick = vi.fn();\nrender(<NotificationItem notification={notification} onClick={onClick} />);\nexpect(screen.getByText('Alice commented')).toBeInTheDocument();\nexpect(screen.getByRole('listitem')).toHaveClass('unread');\nuserEvent.click(screen.getByText('Alice commented'));\nexpect(onClick).toHaveBeenCalledWith(notification);                                                                                                                                                                                                                                                                        |
| `src/components/notifications/NotificationList.tsx`                                    | React Testing Library (Vitest) | Unit test for the list of notifications. Provide an array of notification objects and ensure the list renders a `NotificationItem` for each. If the list has grouping (e.g., by date) or a "mark all as read" button, test those: clicking "mark all as read" should call a handler to mark notifications read. Also verify that if there are no notifications, a "No notifications" message appears.                                                                                                                                                                                                                                                                           | const notes = [{ id: 'n1', message: 'X', read: false }];\nconst onMarkAll = vi.fn();\nrender(<NotificationList notifications={notes} onMarkAllRead={onMarkAll} />);\nexpect(screen.getByText('X')).toBeInTheDocument();\nuserEvent.click(screen.getByText('Mark all as read'));\nexpect(onMarkAll).toHaveBeenCalled();                                                                                                                                                                                                                                                                                                                                                                                                |
| `src/components/notifications/NotificationDropdown.tsx`                                | React Testing Library (Vitest) | Unit test for the notification dropdown component (maybe an icon in the header that shows notifications when clicked). Simulate clicking the bell icon to open the dropdown and verify that `NotificationList` is rendered with notifications. Test that if there are unread notifications, the bell icon might show a badge count. Also ensure clicking outside or pressing ESC closes the dropdown.                                                                                                                                                                                                                                                                           | render(<NotificationDropdown notifications={[{ id:'n1', message:'Hi', read:false }]} />);\nuserEvent.click(screen.getByRole('button', { name: /notifications/i }));\nexpect(screen.getByText('Hi')).toBeVisible();\n// simulate clicking outside\nfireEvent.mouseDown(document.body);\nexpect(screen.queryByText('Hi')).toBeNull();                                                                                                                                                                                                                                                                                                                                                                                   |
| `src/components/notifications/NotificationPreferences.tsx`                             | React Testing Library (Vitest) | Unit test for the notification preferences form. It likely lists various notification types with toggles (email, push, etc.). Provide a sample preferences object (e.g., email:true, push:false) and ensure the switches reflect those states. Simulate toggling a preference and verify that the onChange or save handler is called with updated values. Also test that the "Save Preferences" button (if any) triggers the appropriate action.                                                                                                                                                                                                                                | const prefs = { email: true, push: false };\nrender(<NotificationPreferences preferences={prefs} onSave={onSave} />);\nexpect(screen.getByLabelText('Email Alerts')).toBeChecked();\nuserEvent.click(screen.getByLabelText('Push Notifications'));\nexpect(onSave).toHaveBeenCalledWith(expect.objectContaining({ push: true }));                                                                                                                                                                                                                                                                                                                                                                                     |
