Understood. I will now perform a comprehensive code-level audit of the Lexical editor implementation in your `dattmumas/lnked` repository, focusing on all included plugins—especially the video, image, and tweet embed plugins—and compare each with Lexical's official documentation.

I will provide a structured table with:

- The file containing the issue
- A clear description of the problem
- Recommended solutions with justification
- Specific code-level recommendations for implementation

I'll report back as soon as the analysis is complete.

# Lexical Editor Plugin Issues and Resolutions

Below is a comprehensive analysis of each plugin-related file in the Lexical editor implementation, the problems identified, and detailed solutions with code recommendations. This covers the video (YouTube), image, tweet embed plugins, and extends to all other plugins in the editor for a thorough review.

| **File / Plugin**                                                    | **Problem**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | **Solution**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | **Code Recommendation**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| -------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **PluginLoader (LazyPlugin)** <br/>`PluginLoader.tsx`                | _Lazy plugin architecture not triggering advanced plugins on use._ The `LazyPlugin` system was fixed to load plugins on demand, but advanced plugins remain **disabled by default** and never toggle to “enabled” when needed. As a result, features like equations, polls, YouTube embeds, etc. never actually load at runtime. Additionally, the content-analysis logic (to auto-enable plugins based on content) only runs on initial load, not on user actions.                                                                                                              | **Enable dynamic plugin activation**. Ensure that when a user attempts to use an advanced feature, the corresponding plugin’s `enabled` prop is set to `true` so it loads. You can do this by updating state or configuration when certain commands or UI actions occur. The goal is to **flip the `enabled` flag** at the right time, allowing the lazy-loaded plugin to register its commands. Also consider running content analysis on content changes (or specific triggers) to catch newly added URLs or elements and enable plugins accordingly (not just on initial load).                                                                                                                                                   | **State toggle example:** If using a state like `advancedPlugins`, call a setter when the user triggers an embed. For instance, in the embed insert handler: <br/>`ts<br/>setAdvancedPlugins(prev => ({ ...prev, youtube: true }));<br/>`<br/>This would cause `<LazyPlugin pluginName="youtube" enabled={...} />` to mount the plugin. You should do similarly for Twitter, Polls, Equations, etc. _Alternatively_, remove the lazy gating for critical plugins (set their defaults to `true`) so they are always available when needed. Ensure to follow the pattern in Lexical’s docs: “Enable lazy plugins properly” by binding the `enabled` prop to a condition that turns true when the feature is needed. |
| **YouTube Plugin** <br/>`YouTubePlugin/index.ts`                     | _YouTube video embeds not inserting._ The **INSERT_YOUTUBE_COMMAND** is dispatched (e.g. via the auto-embed menu or slash command), but nothing happens because the YouTube plugin wasn’t loaded at that moment. The plugin is initially disabled (per `advanced.youtube=false`) and so its `useEffect` never ran to register the command handler. In some cases, you might also have seen no error or an error like “YouTubeNode not registered” if the node wasn’t in the initial config.                                                                                      | **Load the YouTube plugin when an embed is attempted.** Before dispatching the insert command, make sure the plugin is loaded (see **PluginLoader** fix above). This can be done by setting `advancedPlugins.youtube = true` when a YouTube URL is detected or when the user opens the embed dialog for YouTube. Also verify that **YouTubeNode is registered** in `initialConfig.nodes` – in this case it is (via `PlaygroundNodes`), so the plugin’s `editor.hasNodes([YouTubeNode])` check will pass. Once the plugin is enabled and the node registered, the command will create and insert a YouTubeNode as intended.                                                                                                           | **Trigger plugin enable:** For example, in the auto-embed onSelect for YouTube, instead of directly dispatching, first call a function to enable the plugin:<br/>`ts<br/>enablePlugin('youtube'); // e.g. set state true<br/>editor.dispatchCommand(INSERT_YOUTUBE_COMMAND, videoId);<br/>`<br/>Ensure `YouTubeNode` is in the initial nodes array (it is in `PlaygroundNodes`). With this in place, the `<YouTubePlugin>` will be mounted in time to handle the command. Alternatively, you could bypass the command and directly insert the node (since `YouTubeNode` is available), but using the command via a loaded plugin is cleaner and follows Lexical’s pattern.                                        |
| **Twitter Plugin** <br/>`TwitterPlugin/index.ts`                     | _Tweet embeds not appearing._ Similar to the YouTube issue, the **INSERT_TWEET_COMMAND** is never handled because the Twitter plugin was not active when the command was dispatched. By default `advanced.twitter` is `false`, so the `<LazyPlugin pluginName="twitter" …>` returns `null` and no command is registered. The user might paste an X/Twitter link and get an “Embed Tweet” suggestion, but clicking it does nothing. (If TweetNode wasn’t registered in config, the plugin would throw an error – in our case it is registered, so the failure is silent.)         | **Activate the Twitter plugin on demand.** Use the same strategy as for YouTube: when the user triggers a tweet embed (via the AutoEmbedPlugin or slash menu), set the state to enable the Twitter plugin _before_ dispatching the insert command. This ensures `TwitterPlugin` mounts and calls `editor.registerCommand` for tweets. With the plugin active and **TweetNode** included in the editor nodes list, the tweet embed will be created. Also ensure the Twitter script (platform.twitter.com/widgets.js) is loaded – the TweetNode’s decorator component handles injecting this on first render, so as long as the node inserts, it will load the widget script.                                                          | **Code fix:** In the handler that inserts tweets (e.g., in AutoEmbedPlugin’s `onSelect` or any “embed tweet” button), toggle the Twitter plugin on:<br/>`ts<br/>setAdvancedPlugins(prev => ({ ...prev, twitter: true }));<br/>editor.dispatchCommand(INSERT_TWEET_COMMAND, tweetId);<br/>`<br/>This matches the Lexical docs guidance to only dispatch the command after confirming the node is registered. Since `TweetNode` is already in `PlaygroundNodes`, the plugin’s internal check will pass and it will insert the node via `$createTweetNode(payload)`.                                                                                                                                                 |
| **Figma Embed Plugin** <br/>`FigmaPlugin`                            | _Figma embeds not working on demand._ The Figma plugin (for embedding Figma prototypes) follows the same lazy pattern. By default `advanced.figma=false`, so unless the initial content contained a “figma.com” link (triggering content analysis to enable it), the **INSERT_FIGMA_COMMAND** isn’t registered. User actions to embed a Figma file (e.g. via slash command or auto-embed) will dispatch the command with no effect.                                                                                                                                              | **Enable Figma plugin when needed.** If users can initiate a Figma embed (through a UI action), update the state to load the Figma plugin at that moment. For example, detect “figma” links in the AutoEmbedPlugin or provide a button for Figma that calls `setAdvancedPlugins(prev => ({ ...prev, figma: true }))` before dispatching the insert command. As always, verify **FigmaNode** is in the initial node list (it is included in `PlaygroundNodes`). Once enabled, the plugin will register its command and calling `editor.dispatchCommand(INSERT_FIGMA_COMMAND, fileId)` will insert the FigmaNode.                                                                                                                      | **Recommendation:** Implement a conditional enabling similar to other embeds. For instance, in the auto-embed config for Figma, instead of blindly dispatching, wrap it: <br/>`ts<br/>if (!advancedPlugins.figma) enablePlugin('figma');<br/>editor.dispatchCommand(INSERT_FIGMA_COMMAND, figmaFileId);<br/>`<br/>This ensures the `<FigmaPlugin>` (lazy-loaded) is mounted to handle the command. Since the node is pre-registered, the embed will then be inserted as expected.                                                                                                                                                                                                                                 |
| **Equations (KaTeX) Plugin** <br/>`EquationsPlugin/index.tsx`        | _Equation editor not responding._ Clicking an “Insert Equation” button opens the equation dialog, but after confirming, the math formula is not inserted. This is because the **INSERT_EQUATION_COMMAND** has no active listener – the EquationsPlugin wasn’t loaded (since `advanced.equations` was false and no initial content contained an equation). Consequently, the `$createEquationNode` command handler never ran. Additionally, the KaTeX CSS/JS might not be loaded until the plugin mounts, so the equation might not render at all if inserted without the plugin. | **Load the equation plugin on insertion and ensure KaTeX availability.** When the user chooses to insert an equation (via toolbar or slash menu), set `advanced.equations = true` so that `<EquationsPlugin>` mounts and registers its command. The plugin will throw if **EquationNode** isn’t in the config, so confirm it’s included (it is, via PlaygroundNodes). Once enabled, dispatch **INSERT_EQUATION_COMMAND** with the equation string and inline/block mode. The plugin’s handler will create the EquationNode and insert it wrapped in a paragraph if needed. The plugin also imports KaTeX CSS on load (and likely KaTeX JS via the EquationNode’s decorator or modal), so loading it at insertion time is acceptable. | **Code changes:** In the toolbar’s `handleInsertEquation`, before calling `showModal('Insert Equation', ...)`, flip the state: <br/>`ts<br/>setAdvancedPlugins(prev => ({ ...prev, equations: true }));<br/>`<br/>This way, by the time the user enters a formula and hits confirm, the EquationsPlugin’s effect has run and the command is ready. In the `InsertEquationDialog.onConfirm`, dispatch as usual. (If you prefer a simpler route, you could set `advanced.equations: true` by default in `defaultPluginConfig` to always load the equations support, since KaTeX is relatively small. Otherwise, dynamic enabling as shown keeps it lazy-loaded.)                                                    |
| **Excalidraw Plugin** <br/>`ExcalidrawPlugin`                        | _Drawing (Excalidraw) embed not inserting._ When users try to insert a drawing canvas (via a slash command or toolbar action), the **INSERT_EXCALIDRAW_COMMAND** does nothing because the Excalidraw plugin was never loaded (default disabled). No error is shown, but the ExcalidrawNode isn’t created.                                                                                                                                                                                                                                                                        | **Enable on action.** Just like other advanced plugins, toggle `advanced.excalidraw = true` when the user invokes the “Insert Drawing” feature. For example, in the toolbar’s `handleInsertExcalidraw` (which currently just dispatches the command), add a step to set the plugin state true before dispatching. Verify **ExcalidrawNode** is in initial nodes (it is in PlaygroundNodes). With the plugin loaded, the dispatch will call `$createExcalidrawNode` and insert the drawing. Also ensure any external dependencies (if the Excalidraw plugin uses a library) are handled when the plugin loads.                                                                                                                        | **Recommended fix:** Modify the insert handler in your toolbar or slash command options: <br/>`ts<br/>if (!advancedPlugins.excalidraw) setAdvancedPlugins(p => ({...p, excalidraw: true}));<br/>editor.dispatchCommand(INSERT_EXCALIDRAW_COMMAND, undefined);<br/>`<br/>This guarantees the `<ExcalidrawPlugin>` is mounted to process the command. The pattern is analogous to Lexical’s standard approach: the plugin registers a command and the UI triggers it, so we must ensure the plugin is active at trigger time.                                                                                                                                                                                       |
| **Poll Plugin** <br/>`PollPlugin`                                    | _Poll not inserting._ Selecting “Insert Poll” opens a dialog, but confirming it doesn’t insert anything because **INSERT_POLL_COMMAND** has no registered handler (plugin was off). The PollNode and UI exist, but without the plugin enabled, the node creation command is never called.                                                                                                                                                                                                                                                                                        | **Enable Poll plugin when needed.** Set `advanced.poll = true` when the user chooses to insert a poll (before or when opening the poll dialog). This allows `<PollPlugin>` to mount and register the command. Make sure **PollNode** is in the node list (yes, in PlaygroundNodes). After enabling, dispatch the insert command with the poll data (question/options) collected from the dialog. With the plugin active, the poll node will be created and inserted.                                                                                                                                                                                                                                                                 | **Code recommendation:** In the poll insertion flow, e.g. in `handleInsertPoll` (which calls `showModal(InsertPollDialog)`), set the plugin state: <br/>`ts<br/>setAdvancedPlugins(p => ({ ...p, poll: true }));<br/>`<br/>Do this before showing the modal or right before dispatching inside the modal’s onConfirm. Then, inside `InsertPollDialog`, the confirm handler should call `editor.dispatchCommand(INSERT_POLL_COMMAND, pollData)`. This way, the PollPlugin’s command handler is ready to create the PollNode.                                                                                                                                                                                       |
| **Sticky Notes** <br/>`StickyPlugin` / `StickyNode`                  | _Sticky note feature integration._ The code registers a **StickyNode** (for post-it style notes) and even provides a toolbar handler (`handleInsertStickyNote`) that directly creates and appends a StickyNode to the editor. Interestingly, this bypasses any plugin command. If a `StickyPlugin` exists, it’s likely not needed for insertion (since the node is inserted directly). The potential issue is that the plugin (if loaded lazily via `advanced.sticky`) might never be triggered or might be unnecessary overhead.                                                | **Simplify or properly utilize plugin.** Since sticky notes are inserted without a command (directly in toolbar), you can either: (a) **Always include StickyNode** in config (which you have) and drop the lazy plugin loader for sticky (no need for a separate plugin if not doing anything extra), or (b) implement a StickyPlugin that registers an insert command and use that via a button (for consistency with other plugins). As it stands, there’s no malfunction (the sticky note inserts correctly) – just ensure consistency. If you keep the direct insertion, you may remove the `LazyPlugin` entry for “sticky” to avoid confusion.                                                                                 | **Code suggestion:** If opting for consistency, create a plugin similar to others: e.g. `INSERT_STICKY_COMMAND` and a StickyPlugin that handles it. Otherwise, if keeping direct insertion, consider removing the lazy import mapping for `'sticky'` in `PLUGIN_LOADERS` to prevent an unused lazy load. This cleanup avoids a situation where `advanced.sticky` might be accidentally enabled (loading a plugin that duplicates functionality). In summary, no major code fix needed for function, but clarity and consistency improvements are recommended.                                                                                                                                                     |
| **Emoji Picker Plugin** <br/>`EmojiPickerPlugin/index.tsx`           | _Emoji autocomplete not appearing._ Typing ":" does not show an emoji menu because the EmojiPickerPlugin is not loaded by default (`advanced.emojiPicker` is false). Since the plugin isn’t mounted, the LexicalTypeaheadMenuPlugin for emojis isn’t active to catch the ":" trigger. In effect, the emoji picker feature is inert unless the plugin is manually enabled.                                                                                                                                                                                                        | **Pre-load or auto-enable the emoji plugin.** Emojis are a common, lightweight feature – you may consider enabling this plugin by default. For example, set `defaultPluginConfig.advanced.emojiPicker = true` so it’s not lazy (since it only loads a small emoji list). If you prefer to keep it lazy, you need a way to toggle it on when the user types ":" – however, without the plugin loaded, detecting that trigger is non-trivial. A practical solution is simply to always include EmojiPickerPlugin (the performance impact is minimal). This ensures the colon trigger is recognized and the emoji menu appears.                                                                                                         | **Code Recommendation:** Easiest fix – in `defaultPluginConfig` set the emojiPicker flag to true so `<LazyPlugin pluginName="emojiPicker" enabled={true} />` loads immediately. For example:<br/>`ts<br/>defaultPluginConfig: { advanced: { ..., emojiPicker: true, ... } }<br/>`<br/>Alternatively, you could programmatically enable it when the user types “:” by listening to key strokes, but that essentially reimplements what the plugin’s meant to do. Pre-loading it is simpler. Once loaded, the EmojiPickerPlugin will use Lexical’s typeahead to suggest emojis on ":" as expected (inserting the chosen emoji as a text node on select).                                                            |
| **Speech-to-Text Plugin** <br/>`SpeechToTextPlugin`                  | _Speech-to-text not functioning._ This plugin (if configured) likely integrates Web Speech API for dictation. By default it’s off (`advanced.speechToText=false`), so any UI to start speech recognition will not find a handler. Possibly no UI is implemented yet.                                                                                                                                                                                                                                                                                                             | **Enable on user request or leave disabled.** If you have a button to start voice dictation, you should set `advanced.speechToText = true` when that button is pressed, so the SpeechToTextPlugin loads and begins capturing speech. If you don’t plan to use this feature now, it can remain off – just note that it won’t work until explicitly enabled.                                                                                                                                                                                                                                                                                                                                                                           | **Code:** If implementing a mic button, have it toggle the plugin state: <br/>`ts<br/>onClick={() => setAdvancedPlugins(p => ({...p, speechToText: true}))}<br/>`<br/>This would load the plugin which likely registers commands or starts the recognition. If the plugin requires a user gesture to start (for permissions), ensure you call the appropriate start function after enabling. If unused, no changes are needed other than possibly removing it from the lazy loader to trim code.                                                                                                                                                                                                                  |
| **Table of Contents Plugin** <br/>`TableOfContentsPlugin`            | _Table of Contents (ToC) not appearing for long documents._ The design was to enable this plugin when content is very long (length > 5000 chars). However, that check only runs on initial content load. If a user gradually writes a long document, the ToC plugin stays disabled (`advanced.tableOfContents` remains false) unless the page is reloaded with that content.                                                                                                                                                                                                     | **Dynamically check content length or enable manually.** To fix, you could run `analyzeContentForPlugins` on each editor update (or at some interval) and if the length threshold is crossed, update `advanced.tableOfContents = true`. A simpler approach: always enable the ToC plugin for editors where it’s needed, or provide a user toggle. If performance is a concern, you might monitor the document length in the OnChange plugin and enable the ToC plugin when it exceeds the threshold.                                                                                                                                                                                                                                 | **Implementation tip:** Use the OnChangePlugin to detect content length: <br/>`ts<br/>onChange(editorState) {<br/>  const text = editorState.read(() => $getRoot().getTextContent());<br/>  if(text.length > 5000 && !advancedPlugins.tableOfContents){<br/>    setAdvancedPlugins(p=>({...p, tableOfContents: true}));<br/>  }<br/>}<br/>`<br/>This will load the TableOfContentsPlugin when needed. Alternatively, if ToC is a desired always-on feature in your app, set its default to true so it’s ready whenever content is lengthy.                                                                                                                                                                        |
| **Table Action Menu** <br/>`TableActionMenuPlugin`                   | _Table action menu unavailable._ This plugin adds a context menu/UI for table edits (merge cells, etc.). It’s off by default and not auto-enabled. Thus, even though basic table functionality works (insertion, editing, via TablePlugin), advanced table actions don’t appear.                                                                                                                                                                                                                                                                                                 | **Enable when table is used.** You can turn this plugin on whenever a table is present or when the user is interacting with a table. For example, after a table is inserted (via Insert Table dialog), set `advanced.tableActionMenu = true`. This will load the plugin that likely adds UI controls for table operations. Alternatively, enable it by default if tables are common and the overhead is low.                                                                                                                                                                                                                                                                                                                         | **Code recommendation:** After inserting a table (e.g., in the InsertTableDialog confirm), call something like:<br/>`ts<br/>editor.dispatchCommand(INSERT_TABLE_COMMAND, {rows, columns});<br/>setAdvancedPlugins(p=>({...p, tableActionMenu: true}));<br/>`<br/>This loads the table action menu plugin by the time the table is in the document. If you want it always on when any table exists, you could also check in OnChange for any TableNode in the document and toggle accordingly. If the plugin is lightweight, you might just default it to true so that users always have table editing options available.                                                                                          |
| **Mention (User Tagging)** <br/>`MentionNode` (node only, no plugin) | _Mention feature incomplete._ The code includes a **MentionNode** class (in PlaygroundNodes) but there is **no MentionPlugin** implemented to handle "@" triggers or insert MentionNodes. This means mentions cannot actually be used – typing "@" does nothing and there’s no UI to select users. The presence of MentionNode in the config without a corresponding plugin is essentially a no-op.                                                                                                                                                                              | **Implement or remove mentions.** If you intend to support @mentions, you need to create a plugin that listens for "@" and opens a suggestion list (similar to the EmojiPicker plugin’s approach, but querying your user list) and inserts a MentionNode on selection. Lexical’s documentation notes that simply registering the node isn’t enough – you must provide the plugin UI/logic for it. If mention functionality is not needed now, consider removing MentionNode from the config to avoid confusion.                                                                                                                                                                                                                      | **Code Recommendation:** To add mentions, create a `MentionsPlugin` using Lexical’s typeahead API: use `useBasicTypeaheadTriggerMatch('@', {...})` to detect triggers and `LexicalTypeaheadMenuPlugin` to render options (e.g., from an API or list of usernames). On select, insert a MentionNode with the chosen user’s data. The Lexical playground has an example implementation you can reference. If not implementing, simply exclude `MentionNode` from `PlaygroundNodes` to streamline the setup.                                                                                                                                                                                                         |

**References:** The above solutions reference Lexical’s official guidelines and examples. According to Lexical’s docs, custom nodes must be registered in the editor configuration for their plugins to function. The plugins (like TwitterPlugin, YouTubePlugin, etc.) are added as React components inside the LexicalComposer and register insertion commands that create the corresponding nodes. In our case, the core issue was not the plugin code itself (which closely follows Lexical’s official plugins) but the lazy-loading mechanism failing to activate those plugins at the right time. By adjusting when and how we enable these plugins – either by default or in response to user actions – we can fix the broken embeddings and other advanced features. This approach aligns with Lexical’s recommended usage (e.g., dispatching commands only after ensuring the plugin/node is ready). Each plugin now will work as intended, allowing users to embed media and use advanced features in the editor.
