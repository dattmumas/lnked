// ---------------------------------------------------------------------------
// /api/videos/[id]/route.ts
//
// RESTful handler for single‑video operations (GET, PATCH, DELETE).
// Mux-integrated with retry logic, proper SDK usage, and error resilience.
// Uses Zod for parameter / body validation and returns uniform JSON envelopes.
// ---------------------------------------------------------------------------

import { createHash } from 'crypto';

import Mux from '@mux/mux-node';
import { NextRequest, NextResponse } from 'next/server';
import { z } from 'zod';

import { createServerSupabaseClient } from '@/lib/supabase/server';

// ─────────────────────────────────────────────────────────────────────────────
// Types & Interfaces
// ─────────────────────────────────────────────────────────────────────────────
interface VideoAsset {
  id: string;
  mux_asset_id: string | null;
  mux_playback_id: string | null;
  title: string | null;
  description: string | null;
  duration: number | null;
  status: string | null;
  aspect_ratio: string | null;
  created_by: string | null;
  created_at: string | null;
  updated_at: string | null;
  mux_upload_id: string | null;
  mp4_support: string | null;
  is_public: boolean | null;
  playback_policy: string | null;
  encoding_tier: string | null;
  collective_id: string | null;
  post_id: string | null;
  comment_count: number;
  deleted_at?: string | null;
}

interface MuxRetryOptions {
  maxRetries: number;
  baseDelay: number;
  maxDelay: number;
}

interface MuxError extends Error {
  statusCode?: number;
  status?: number;
}



// ─────────────────────────────────────────────────────────────────────────────
// Constants & Helpers
// ─────────────────────────────────────────────────────────────────────────────
const VIDEO_ID = z.string().uuid('invalid_video_id');

// HTTP Status Codes
const HTTP_STATUS_INTERNAL_SERVER_ERROR = 500;
const HTTP_STATUS_TOO_MANY_REQUESTS = 429;
const HTTP_STATUS_UNAUTHORIZED = 401;
const HTTP_STATUS_BAD_REQUEST = 400;
const HTTP_STATUS_NOT_FOUND = 404;
const HTTP_STATUS_NOT_MODIFIED = 304;

// Retry and Timing Constants
const EXPONENTIAL_BACKOFF_BASE = 2;
const RANDOM_JITTER_MAX_MS = 1000;
const DEFAULT_BASE_DELAY_MS = 1000;
const DEFAULT_MAX_DELAY_MS = 8000;
const DEFAULT_MAX_RETRIES = 3;
const CACHE_MAX_AGE_SECONDS = 60;

// Environment-based encoding tiers - Fix #13
const getAllowedEncodingTiers = (): readonly string[] => {
  const envTiers = process.env.MUX_ALLOWED_TIERS;
  if (envTiers !== undefined && envTiers.trim().length > 0) {
    return envTiers.split(',').map(tier => tier.trim()) as readonly string[];
  }
  return ['smart', 'baseline'] as const; // fallback
};

const ALLOWED_ENCODING_TIERS = getAllowedEncodingTiers();

const DEFAULT_RETRY_OPTIONS: MuxRetryOptions = {
  maxRetries: DEFAULT_MAX_RETRIES,
  baseDelay: DEFAULT_BASE_DELAY_MS,
  maxDelay: DEFAULT_MAX_DELAY_MS,
};

// Singleton Mux client - prevents per-request instantiation overhead
let muxClient: Mux | null = null;

function getMuxClient(): Mux {
  if (muxClient === null) {
    const id = process.env.MUX_TOKEN_ID;
    const secret = process.env.MUX_TOKEN_SECRET;
    
    if (id === undefined || id.trim().length === 0) {
      throw new Error('MUX_TOKEN_ID environment variable is required');
    }
    
    if (secret === undefined || secret.trim().length === 0) {
      throw new Error('MUX_TOKEN_SECRET environment variable is required');
    }
    
    muxClient = new Mux({ tokenId: id, tokenSecret: secret });
  }
  
  return muxClient;
}

// Fix #4: Proper retry detection based on statusCode
function isRetryableError(error: MuxError): boolean {
  // Check status code from Mux SDK error
  const statusCode = error.statusCode ?? error.status;
  
  if (statusCode !== undefined) {
    return statusCode >= HTTP_STATUS_INTERNAL_SERVER_ERROR || statusCode === HTTP_STATUS_TOO_MANY_REQUESTS;
  }
  
  // Fallback to message-based detection for specific patterns
  const message = error.message.toLowerCase();
  return message.includes('timeout') || 
         message.includes('network') ||
         message.includes('connection');
}

// Fix #4: Retry wrapper with proper error detection
async function withMuxRetry<T>(
  operation: () => Promise<T>,
  context: string,
  options: MuxRetryOptions = DEFAULT_RETRY_OPTIONS,
): Promise<T> {
  let lastError: Error = new Error('Unknown error');
  
  for (let attempt = 0; attempt <= options.maxRetries; attempt++) {
    try {
      return await operation();
    } catch (error: unknown) {
      lastError = error instanceof Error ? error : new Error(String(error));
      
      // Don't retry on final attempt
      if (attempt === options.maxRetries) {
        break;
      }
      
      // Check if error is retryable using proper statusCode detection
      if (!isRetryableError(lastError as MuxError)) {
        break;
      }
      
      // Fix #7: Bounded exponential backoff with proper max delay
      const exponentialDelay = options.baseDelay * Math.pow(EXPONENTIAL_BACKOFF_BASE, attempt);
      const delay = Math.min(exponentialDelay + Math.random() * RANDOM_JITTER_MAX_MS, options.maxDelay);
      
      logWarn(`Mux ${context} attempt ${attempt + 1} failed, retrying in ${delay}ms`, {
        error: lastError.message,
        attempt: attempt + 1,
        maxRetries: options.maxRetries,
        statusCode: (lastError as MuxError).statusCode ?? (lastError as MuxError).status,
      });
      
      await new Promise<void>(resolve => {
        setTimeout(() => {
          resolve();
        }, delay);
      });
    }
  }
  
  // Handle rate limit errors specially
  const muxError = lastError as MuxError;
  const statusCode = muxError.statusCode ?? muxError.status;
  if (statusCode === HTTP_STATUS_TOO_MANY_REQUESTS || lastError.message.includes('rate_limit_exceeded')) {
    throw new Error('RATE_LIMITED');
  }
  
  throw lastError;
}

// Fix #12: Central logging with sampling and levels
const LOG_LEVEL = process.env.LOG_LEVEL ?? 'error';
const LOG_SAMPLING_RATE = parseFloat(process.env.LOG_SAMPLING_RATE ?? '1.0');

function shouldLog(): boolean {
  return Math.random() < LOG_SAMPLING_RATE;
}

function logError(context: string, error: unknown, metadata?: Record<string, unknown>): void {
  if (LOG_LEVEL === 'none' || !shouldLog()) return;
  
  const sanitizedMetadata = {
    ...metadata,
    // Redact sensitive fields
    user_id: metadata?.user_id !== undefined ? '[REDACTED]' : undefined,
    video_id: metadata?.video_id !== undefined ? metadata.video_id : undefined,
  };
  
  // In production, send to central logging service (Datadog, Loki, etc.)
  if (process.env.NODE_ENV === 'production') {
    // TODO: Send to central logging service
    // Example: datadog.logger.error(`[${context}]`, { error, ...sanitizedMetadata });
  } else {
    console.error(`[${context}]`, {
      error: error instanceof Error ? error.message : String(error),
      timestamp: new Date().toISOString(),
      ...sanitizedMetadata,
    });
  }
}

function logWarn(message: string, metadata?: Record<string, unknown>): void {
  if (LOG_LEVEL === 'none' || LOG_LEVEL === 'error' || !shouldLog()) return;
  
  if (process.env.NODE_ENV === 'production') {
    // TODO: Send to central logging service
  } else {
    console.warn(message, metadata);
  }
}

// Fix #5: Idempotency protection for playback policy changes
const playbackPolicyMutex = new Map<string, Promise<void>>();

// Fix #11: Enhanced ETag generation including more fields
function generateETag(video: VideoAsset): string {
  const hashableFields = {
    id: video.id,
    updated_at: video.updated_at,
    comment_count: video.comment_count,
    playback_policy: video.playback_policy,
    is_public: video.is_public,
    mux_playback_id: video.mux_playback_id,
    status: video.status,
    deleted_at: video.deleted_at,
  };
  
  const hash = createHash('sha1')
    .update(JSON.stringify(hashableFields))
    .digest('hex');
    
  return `"${hash}"`;
}

// Fix #14: Ownership validation with RLS compliance
async function assertOwnership(
  supabase: ReturnType<typeof createServerSupabaseClient>,
  userId: string,
  videoId: string,
): Promise<VideoAsset> {
  // Use authenticated user client to respect RLS
  const { data, error } = await supabase
    .from('video_assets')
    .select('*')
    .eq('id', videoId)
    .eq('created_by', userId)
    .is('deleted_at', null) // Exclude soft-deleted videos
    .maybeSingle(); // Use maybeSingle to avoid 406 errors
    
  if (error !== null) {
    throw new Error(`Database query failed: ${error.message}`);
  }
  
  if (data === null) {
    throw new Error('Video not found or access denied');
  }
  
  return data as VideoAsset;
}

// Fix #6: Queue-based asset cleanup (preparation for durable queue)
function scheduleCleanupJob(video: VideoAsset): void {
  // In production, push to durable queue (Supabase pgmq, SQS, Redis Streams)
  
  // TODO: Implement actual queue integration
  // Example: await pgmq.send('mux_cleanup_queue', cleanupJob);
  
  // Fallback: immediate cleanup for now (but logged as async)
  cleanupMuxResources(video).catch((cleanupError: unknown) => {
    logError('async_mux_cleanup_failed', cleanupError, { video_id: video.id });
  });
}

// Fix #1: Correct Mux SDK method name (.delete() for v11+)
// Fix #8: Handle orphaned assets after upload cancellation
async function cleanupMuxResources(video: VideoAsset): Promise<void> {
  const mux = getMuxClient();
  
  try {
    // Handle asset deletion with correct SDK method
    if (video.mux_asset_id !== null && video.mux_asset_id !== undefined && video.mux_asset_id.trim().length > 0) {
      await withMuxRetry(
        () => mux.video.assets.delete(video.mux_asset_id as string), // Fix #1: Use .delete() method
        'asset_deletion',
      );
    }
    
    // Handle upload cancellation with orphaned asset awareness
    if (video.mux_upload_id !== null && video.mux_upload_id !== undefined && video.mux_upload_id.trim().length > 0) {
      try {
        await withMuxRetry(
          () => mux.video.uploads.cancel(video.mux_upload_id as string),
          'upload_cancellation',
        );
      } catch (cancelError: unknown) {
        // Upload might have already completed, creating an orphaned asset
        if (cancelError instanceof Error && cancelError.message.includes('already completed')) {
          logWarn('Upload completed before cancellation - potential orphaned asset', {
            upload_id: video.mux_upload_id,
            video_id: video.id,
          });
          
          // Fix #8: Subscribe to video.upload.asset_created webhook
          // In production, implement webhook handler to track and clean orphaned assets
          // For now, log for manual follow-up
        }
      }
    }
  } catch (cleanupError: unknown) {
    logError('mux_cleanup_failed', cleanupError, { 
      video_id: video.id,
      mux_asset_id: video.mux_asset_id,
      mux_upload_id: video.mux_upload_id,
    });
    // Don't throw - cleanup failures shouldn't block the response
  }
}

// Fix #5: Idempotent playback policy update with mutex protection
async function updatePlaybackPolicy(
  video: VideoAsset, 
  newIsPublic: boolean,
  supabase: ReturnType<typeof createServerSupabaseClient>, // Fix #2: Inject client
): Promise<void> {
  if (video.mux_asset_id === null || video.is_public === newIsPublic) {
    return; // No change needed
  }
  
  // Fix #5: Mutex protection against concurrent policy changes
  const mutexKey = video.id;
  const existingMutex = playbackPolicyMutex.get(mutexKey);
  if (existingMutex !== undefined) {
    await existingMutex;
    return; // Another request is already handling this
  }
  
  const operationPromise = (async (): Promise<void> => {
    const mux = getMuxClient();
    const newPolicy = newIsPublic ? 'public' : 'signed';
    
    try {
      // If there's an existing playback ID with wrong policy, delete it
      if (video.mux_playback_id !== null) {
        await withMuxRetry(
          () => mux.video.assets.deletePlaybackId(video.mux_asset_id as string, video.mux_playback_id as string),
          'playback_id_deletion',
        );
      }
      
      // Create new playback ID with correct policy
      const response = await withMuxRetry(
        () => mux.video.assets.createPlaybackId(video.mux_asset_id as string, { policy: newPolicy }),
        'playback_id_creation',
      );
      
      // Update database with new playback ID using injected client
      await supabase
        .from('video_assets')
        .update({ 
          mux_playback_id: response.id,
          playback_policy: newPolicy,
        })
        .eq('id', video.id);
        
    } catch (error: unknown) {
      logError('playback_policy_sync_failed', error, { video_id: video.id });
      throw new Error('Failed to synchronize playback policy with Mux');
    }
  })();
  
  playbackPolicyMutex.set(mutexKey, operationPromise);
  
  try {
    await operationPromise;
  } finally {
    playbackPolicyMutex.delete(mutexKey);
  }
}

// ─────────────────────────────────────────────────────────────────────────────
// GET  /api/videos/[id] - with enhanced ETag support
// ─────────────────────────────────────────────────────────────────────────────
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }, // Fixed: params IS a Promise in Next.js 15
): Promise<NextResponse> {
  const { id } = await params; // Fixed: Await params in Next.js 15
  
  try {
    const supabase = createServerSupabaseClient();
    
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();
    
    if (authError !== null || user === null) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: HTTP_STATUS_UNAUTHORIZED });
    }

    const videoId = VIDEO_ID.parse(id);
    const video = await assertOwnership(supabase, user.id, videoId);
    
    // Fix #11: Enhanced ETag generation with more fields
    const etag = generateETag(video);
    const ifNoneMatch = request.headers.get('if-none-match');
    
    if (ifNoneMatch === etag) {
      return new NextResponse(null, { status: HTTP_STATUS_NOT_MODIFIED });
    }
    
    const response = NextResponse.json({ data: video });
    response.headers.set('ETag', etag);
    response.headers.set('Cache-Control', `private, max-age=${CACHE_MAX_AGE_SECONDS}`);
    
    return response;
  } catch (error: unknown) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Invalid video ID format' },
        { status: HTTP_STATUS_BAD_REQUEST }
      );
    }
    
    if (error instanceof Error && error.message.includes('not found')) {
      return NextResponse.json(
        { error: 'Video not found' },
        { status: HTTP_STATUS_NOT_FOUND }
      );
    }
    
    logError('GET_video_error', error, { video_id: id });
    return NextResponse.json({ error: 'Internal server error' }, { status: HTTP_STATUS_INTERNAL_SERVER_ERROR });
  }
}

// ─────────────────────────────────────────────────────────────────────────────
// PATCH /api/videos/[id] - with environment-based encoding tier validation
// ─────────────────────────────────────────────────────────────────────────────
const UpdateSchema = z.object({
  title: z.string().trim().min(1).optional(),
  description: z.string().trim().optional(),
  privacy_setting: z.enum(['public', 'private']).optional(),
  encoding_tier: z.enum(ALLOWED_ENCODING_TIERS as [string, ...string[]]).optional(), // Fix #13: Env-based tiers
  collective_id: z.string().uuid().nullable().optional(),
  post_id: z.string().uuid().nullable().optional(),
}).strict();

export async function PATCH(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }, // Fix #3: Remove Promise wrapper
): Promise<NextResponse> {
  const { id } = params; // Fix #3: No await needed
  
  try {
    const supabase = createServerSupabaseClient();
    
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();
    
    if (authError !== null || user === null) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: HTTP_STATUS_UNAUTHORIZED });
    }

    const videoId = VIDEO_ID.parse(id);
    const video = await assertOwnership(supabase, user.id, videoId);

    const body = UpdateSchema.parse(await request.json());
    const updateData: Record<string, unknown> = { ...body };

    // Handle privacy setting changes with proper Mux sync
    if (body.privacy_setting !== undefined) {
      const newIsPublic = body.privacy_setting === 'public';
      
      // Update playback policy in Mux if needed (with injected client)
      if (video.mux_asset_id !== null) {
        await updatePlaybackPolicy(video, newIsPublic, supabase); // Fix #2: Pass client
      }
      
      updateData.is_public = newIsPublic;
      updateData.playback_policy = newIsPublic ? 'public' : 'signed';
      delete updateData.privacy_setting;
    }

    if (Object.keys(updateData).length === 0) {
      return NextResponse.json({ data: { unchanged: true } });
    }

    updateData.updated_at = new Date().toISOString();

    // Fix #14: Use authenticated client to respect RLS
    const { data, error } = await supabase
      .from('video_assets')
      .update(updateData)
      .eq('id', videoId)
      .eq('created_by', user.id) // RLS-safe: only update own videos
      .select()
      .single();

    if (error !== null) {
      logError('update_video_error', error, { video_id: videoId });
      return NextResponse.json(
        { error: 'Failed to update video' },
        { status: HTTP_STATUS_INTERNAL_SERVER_ERROR }
      );
    }
    
    return NextResponse.json({ data });
  } catch (error: unknown) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Invalid request data', details: error.errors },
        { status: HTTP_STATUS_BAD_REQUEST }
      );
    }
    
    if (error instanceof Error && error.message.includes('not found')) {
      return NextResponse.json(
        { error: 'Video not found' },
        { status: HTTP_STATUS_NOT_FOUND }
      );
    }
    
    if (error instanceof Error && error.message === 'RATE_LIMITED') {
      return NextResponse.json(
        { error: 'Service temporarily unavailable due to rate limiting' },
        { status: HTTP_STATUS_TOO_MANY_REQUESTS }
      );
    }
    
    logError('PATCH_video_error', error, { video_id: id });
    return NextResponse.json({ error: 'Internal server error' }, { status: HTTP_STATUS_INTERNAL_SERVER_ERROR });
  }
}

// ─────────────────────────────────────────────────────────────────────────────
// DELETE /api/videos/[id] - with queue-based cleanup and proper RLS
// ─────────────────────────────────────────────────────────────────────────────
export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }, // Fix #3: Remove Promise wrapper
): Promise<NextResponse> {
  const { id } = params; // Fix #3: No await needed
  
  try {
    const supabase = createServerSupabaseClient();
    
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();
    
    if (authError !== null || user === null) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: HTTP_STATUS_UNAUTHORIZED });
    }

    const videoId = VIDEO_ID.parse(id);
    const video = await assertOwnership(supabase, user.id, videoId);

    // Soft delete: mark as deleted instead of hard delete
    // Fix #14: Use authenticated client to respect RLS
    const { error: deleteError } = await supabase
      .from('video_assets')
      .update({ 
        deleted_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      })
      .eq('id', videoId)
      .eq('created_by', user.id); // RLS-safe: only delete own videos

    if (deleteError !== null) {
      logError('soft_delete_failed', deleteError, { video_id: videoId });
      return NextResponse.json(
        { error: 'Failed to delete video' },
        { status: HTTP_STATUS_INTERNAL_SERVER_ERROR }
      );
    }

    // Respond immediately with 202 Accepted
    const response = NextResponse.json({ 
      deleted: true, 
      message: 'Video deletion initiated' 
    }, { status: 202 });

    // Fix #6: Schedule cleanup via durable queue (preparation)
    scheduleCleanupJob(video);
    
    return response;
  } catch (error: unknown) {
    if (error instanceof z.ZodError) {
      return NextResponse.json(
        { error: 'Invalid video ID format' },
        { status: HTTP_STATUS_BAD_REQUEST }
      );
    }
    
    if (error instanceof Error && error.message.includes('not found')) {
      return NextResponse.json(
        { error: 'Video not found' },
        { status: HTTP_STATUS_NOT_FOUND }
      );
    }
    
    if (error instanceof Error && error.message === 'RATE_LIMITED') {
      return NextResponse.json(
        { error: 'Service temporarily unavailable due to rate limiting' },
        { status: HTTP_STATUS_TOO_MANY_REQUESTS }
      );
    }
    
    logError('DELETE_video_error', error, { video_id: id });
    return NextResponse.json({ error: 'Internal server error' }, { status: HTTP_STATUS_INTERNAL_SERVER_ERROR });
  }
}