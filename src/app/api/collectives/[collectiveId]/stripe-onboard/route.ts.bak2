import { NextRequest, NextResponse } from 'next/server';

import { getStripe } from '@/lib/stripe';
import { createRequestScopedSupabaseClient } from '@/lib/supabase/request-scoped';
import { createMetricsTimer, recordAPIMetrics } from '@/lib/utils/metrics';
import { createAPILogger } from '@/lib/utils/structured-logger';

import type Stripe from 'stripe';

// Constants to replace magic strings and numbers
const STRIPE_CONNECT_TYPE = 'express' as const;
const STRIPE_CONNECT_CAPABILITIES = {
  card_payments: { requested: true },
  transfers: { requested: true },
} as const;

// Time constants
const SECONDS_PER_MINUTE = 60;
const MINUTES_PER_HOUR = 60;
const HOURS_PER_DAY = 24;
const MILLISECONDS_PER_SECOND = 1000;

// Cache configuration
const CACHE_CLEANUP_INTERVAL = MINUTES_PER_HOUR * SECONDS_PER_MINUTE * MILLISECONDS_PER_SECOND; // 1 hour
const CACHE_TTL = HOURS_PER_DAY * MINUTES_PER_HOUR * SECONDS_PER_MINUTE * MILLISECONDS_PER_SECOND; // 24 hours

// HTTP status codes
const HTTP_STATUS = {
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  FORBIDDEN: 403,
  NOT_FOUND: 404,
  TOO_MANY_REQUESTS: 429,
  INTERNAL_SERVER_ERROR: 500,
} as const;

// Cache for account links to prevent rate limiting
const accountLinkCache = new Map<string, {
  url: string;
  createdAt: number;
  expiresAt: number;
}>();

// Environment validation
function validateEnvironment(): void {
  if (process.env.NODE_ENV === 'production' && 
      (process.env.NEXT_PUBLIC_SITE_URL === null || 
       process.env.NEXT_PUBLIC_SITE_URL === undefined || 
       process.env.NEXT_PUBLIC_SITE_URL === '')) {
    throw new Error('NEXT_PUBLIC_SITE_URL is required in production');
  }
}

// Idempotency check for Stripe account creation
async function getOrCreateStripeAccount(
  stripe: Stripe,
  collectiveId: string,
): Promise<{ accountId: string; isNew: boolean }> {
  // Note: Stripe API doesn't support filtering by metadata directly
  // We'll use the collectiveId as idempotency key for account creation
  try {
    const account = await stripe.accounts.create({
      type: STRIPE_CONNECT_TYPE,
      capabilities: STRIPE_CONNECT_CAPABILITIES,
      metadata: { collectiveId },
    }, {
      idempotencyKey: `collective-${collectiveId}`,
    });

    return {
      accountId: account.id,
      isNew: true,
    };
  } catch (error: unknown) {
    // If idempotency key was already used, Stripe returns the original result
    if (error instanceof Error && 'type' in error) {
      const stripeError = error as { type: string; account?: { id: string } };
      if (stripeError.type === 'idempotency_error' && 
          stripeError.account !== null && 
          stripeError.account !== undefined && 
          stripeError.account.id !== null && 
          stripeError.account.id !== undefined) {
        return {
          accountId: stripeError.account.id,
          isNew: false,
        };
      }
    }
    throw error;
  }
}

// Get cached or create new account link
async function getOrCreateAccountLink(
  stripe: Stripe,
  stripeAccountId: string,
  collectiveId: string,
  siteUrl: string,
): Promise<string> {
  const cacheKey = `${stripeAccountId}:${collectiveId}`;
  const cached = accountLinkCache.get(cacheKey);
  const now = Date.now();

  // Return cached link if still valid
  if (cached !== undefined && cached.expiresAt > now) {
    return cached.url;
  }

  // Create new account link
  const accountLink = await stripe.accountLinks.create({
    account: stripeAccountId,
    refresh_url: `${siteUrl}/dashboard/collectives/${collectiveId}/settings?stripe=refresh`,
    return_url: `${siteUrl}/dashboard/collectives/${collectiveId}/settings?stripe=return`,
    type: 'account_onboarding',
  });

  // Cache the link (Stripe links expire in 24 hours)
  accountLinkCache.set(cacheKey, {
    url: accountLink.url,
    createdAt: now,
    expiresAt: now + CACHE_TTL,
  });

  return accountLink.url;
}

// Cleanup expired cache entries
function cleanupCache(): void {
  const now = Date.now();
  for (const [key, value] of accountLinkCache.entries()) {
    if (value.expiresAt <= now) {
      accountLinkCache.delete(key);
    }
  }
}

// Schedule cache cleanup
setInterval(cleanupCache, CACHE_CLEANUP_INTERVAL);

// Stripe error interface for type safety
interface StripeErrorLike {
  type: string;
  message: string;
}

// Map Stripe errors to appropriate HTTP status codes
function mapStripeError(error: unknown): { status: number; message: string } {
  if (error instanceof Error && 'type' in error) {
    const stripeError = error as StripeErrorLike;
    
    switch (stripeError.type) {
      case 'StripeCardError':
      case 'StripeInvalidRequestError':
        return { status: HTTP_STATUS.BAD_REQUEST, message: stripeError.message };
      case 'StripeAuthenticationError':
        return { status: HTTP_STATUS.UNAUTHORIZED, message: 'Authentication failed' };
      case 'StripePermissionError':
        return { status: HTTP_STATUS.FORBIDDEN, message: 'Permission denied' };
      case 'StripeRateLimitError':
        return { status: HTTP_STATUS.TOO_MANY_REQUESTS, message: 'Rate limit exceeded' };
      default:
        return { status: HTTP_STATUS.INTERNAL_SERVER_ERROR, message: 'Payment service error' };
    }
  }
  
  return { status: HTTP_STATUS.INTERNAL_SERVER_ERROR, message: 'Unknown error' };
}

// Type for collective data
interface CollectiveData {
  id: string;
  stripe_account_id: string | null;
  owner_id: string;
}

// Enhanced ownership check supporting admin roles
async function validateCollectiveAccess(
  supabase: ReturnType<typeof createRequestScopedSupabaseClient>,
  collectiveId: string,
  userId: string,
): Promise<{ collective: CollectiveData | null; hasAccess: boolean }> {
  // Query collective with member roles (supporting multi-owner/admin)
  const { data: memberData, error: memberError } = await supabase
    .from('collective_members')
    .select(`
      role,
      collective:collectives!inner(
        id,
        stripe_account_id,
        owner_id
      )
    `)
    .eq('collective_id', collectiveId)
    .eq('user_id', userId)
    .in('role', ['owner', 'admin'])
    .single();

  if (memberError !== null || memberData === null) {
    // Fallback to direct owner check
    const { data: collectiveData, error: collectiveError } = await supabase
      .from('collectives')
      .select('id, stripe_account_id, owner_id')
      .eq('id', collectiveId)
      .eq('owner_id', userId)
      .single();

    if (collectiveError !== null || collectiveData === null) {
      return { collective: null, hasAccess: false };
    }

    return { collective: collectiveData as CollectiveData, hasAccess: true };
  }

  return { collective: memberData.collective as CollectiveData, hasAccess: true };
}

export async function POST(
  req: NextRequest,
  { params }: { params: Promise<{ collectiveId: string }> }, // Fixed: params IS a Promise in Next.js 15
): Promise<NextResponse> {
  const logger = createAPILogger(req, '/api/collectives/[collectiveId]/stripe-onboard');
  const timer = createMetricsTimer();
  let userId: string | undefined;

  try {
    // Validate environment early
    validateEnvironment();

    const { collectiveId } = await params; // Await params in Next.js 15
    if (collectiveId === null || collectiveId === undefined || collectiveId === '') {
      const duration = timer();
      recordAPIMetrics({
        endpoint: '/api/collectives/[collectiveId]/stripe-onboard',
        method: 'POST',
        statusCode: HTTP_STATUS.BAD_REQUEST,
        duration,
        error: 'Missing collectiveId',
      });

      return NextResponse.json(
        { error: 'Missing collectiveId' },
        { status: HTTP_STATUS.BAD_REQUEST }
      );
    }

    // Session-aware Supabase client with proper context
    const supabase = createRequestScopedSupabaseClient(req);
    
    // Authentication check
    const {
      data: { user },
      error: authError,
    } = await supabase.auth.getUser();

    if (authError !== null || user === null) {
      const duration = timer();
      recordAPIMetrics({
        endpoint: '/api/collectives/[collectiveId]/stripe-onboard',
        method: 'POST',
        statusCode: HTTP_STATUS.UNAUTHORIZED,
        duration,
        error: 'Authentication failed',
      });

      logger.warn('Unauthorized Stripe onboarding attempt', {
        statusCode: HTTP_STATUS.UNAUTHORIZED,
        error: authError?.message,
        metadata: {
          collectiveId,
        },
      });

      return NextResponse.json({ error: 'Unauthorized' }, { status: HTTP_STATUS.UNAUTHORIZED });
    }

    userId = user.id;

    // Enhanced ownership check with admin role support
    const { collective, hasAccess } = await validateCollectiveAccess(
      supabase,
      collectiveId,
      userId,
    );

    if (!hasAccess || collective === null) {
      const statusCode = collective === null ? HTTP_STATUS.NOT_FOUND : HTTP_STATUS.FORBIDDEN;
      const duration = timer();
      recordAPIMetrics({
        endpoint: '/api/collectives/[collectiveId]/stripe-onboard',
        method: 'POST',
        statusCode,
        duration,
        userId,
        error: collective === null ? 'Collective not found' : 'Access denied',
      });

      const errorMessage = collective === null ? 'Collective not found' : 'Forbidden: Insufficient permissions';
      return NextResponse.json(
        { error: errorMessage },
        { status: statusCode }
      );
    }

    // Initialize Stripe
    const stripe = getStripe();
    if (stripe === null || stripe === undefined) {
      const duration = timer();
      recordAPIMetrics({
        endpoint: '/api/collectives/[collectiveId]/stripe-onboard',
        method: 'POST',
        statusCode: HTTP_STATUS.INTERNAL_SERVER_ERROR,
        duration,
        userId,
        error: 'Stripe not configured',
      });

      logger.error('Stripe not configured', {
        userId,
        statusCode: HTTP_STATUS.INTERNAL_SERVER_ERROR,
        metadata: {
          collectiveId,
        },
      });

      return NextResponse.json(
        { error: 'Payment service unavailable' },
        { status: HTTP_STATUS.INTERNAL_SERVER_ERROR }
      );
    }

    let stripeAccountId = collective.stripe_account_id;
    let accountCreated = false;

    // Get or create Stripe account with idempotency
    if (stripeAccountId === null || stripeAccountId === undefined || stripeAccountId === '') {
      const { accountId, isNew } = await getOrCreateStripeAccount(stripe, collectiveId);
      stripeAccountId = accountId;
      accountCreated = isNew;

      // Save to database only if new account was created
      if (isNew) {
        const { error: updateError } = await supabase
          .from('collectives')
          .update({ stripe_account_id: stripeAccountId })
          .eq('id', collectiveId);

        if (updateError !== null) {
          const duration = timer();
          recordAPIMetrics({
            endpoint: '/api/collectives/[collectiveId]/stripe-onboard',
            method: 'POST',
            statusCode: HTTP_STATUS.INTERNAL_SERVER_ERROR,
            duration,
            userId,
            error: 'Database update failed',
          });

          logger.error('Failed to save Stripe account ID', {
            userId,
            statusCode: HTTP_STATUS.INTERNAL_SERVER_ERROR,
            error: updateError,
            metadata: {
              collectiveId,
              stripeAccountId,
            },
          });

          return NextResponse.json(
            { error: 'Failed to save payment account' },
            { status: HTTP_STATUS.INTERNAL_SERVER_ERROR }
          );
        }
      }
    }

    // Get site URL with production validation
    const siteUrl = process.env.NEXT_PUBLIC_SITE_URL ?? 'http://localhost:3000';

    // Create or reuse account link (prevents rate limiting)
    const onboardingUrl = await getOrCreateAccountLink(
      stripe,
      stripeAccountId,
      collectiveId,
      siteUrl,
    );

    const duration = timer();
    recordAPIMetrics({
      endpoint: '/api/collectives/[collectiveId]/stripe-onboard',
      method: 'POST',
      statusCode: 200,
      duration,
      userId,
    });

    logger.info('Stripe onboarding link created successfully', {
      userId,
      statusCode: 200,
      duration,
      metadata: {
        collectiveId,
        stripeAccountId,
        accountCreated,
      },
    });

    return NextResponse.json({ url: onboardingUrl });

  } catch (error: unknown) {
    const duration = timer();
    
    // Map Stripe errors to appropriate status codes
    const { status, message } = mapStripeError(error);
    
    recordAPIMetrics({
      endpoint: '/api/collectives/[collectiveId]/stripe-onboard',
      method: 'POST',
      statusCode: status,
      duration,
      userId,
      error: error instanceof Error ? error.message : 'Unknown error',
    });

    logger.error('Stripe onboarding failed', {
      userId,
      statusCode: status,
      duration,
      error: error instanceof Error ? error : new Error(String(error)),
    });

    return NextResponse.json(
      { error: message },
      { status }
    );
  }
}

