/* eslint-disable no-magic-numbers */

import { cookies } from 'next/headers';
import { NextRequest, NextResponse } from 'next/server';

import { getSupabaseSingleton, createCookieHandler } from '@/lib/supabase/singleton-client';
import { 
  AuthSecurityValidator, 
  CookieSecurityManager, 
  SessionManager,
  type AuthCallbackPayload 
} from '@/lib/utils/auth-security';
import { recordAPIMetrics, createMetricsTimer } from '@/lib/utils/metrics';
import { checkRateLimit, getClientIP } from '@/lib/utils/rate-limiting';
import { APILogger } from '@/lib/utils/structured-logger';


// Constants
const RATE_LIMIT_CONFIG = {
  maxRequests: 30,
  windowMs: 60 * 1000, // 1 minute
} as const;

const LOG_CONFIG = {
  verbose: process.env.VERBOSE_AUTH_CALLBACK === 'true',
  context: 'auth-callback',
} as const;

const USER_ID_ANONYMIZATION_LENGTH = 8;

// Initialize logger
const logger = new APILogger({ endpoint: '/api/auth/callback' });

/**
 * Enterprise-grade auth callback route with comprehensive security
 * 
 * Security Features:
 * 1. CSRF/Origin validation
 * 2. Body size/schema validation  
 * 3. Rate limiting (30 req/min/IP)
 * 4. Singleton Supabase client
 * 5. Cookie security enforcement
 * 6. Session rollback on errors
 * 7. Structured logging with PII protection
 * 8. Complete observability metrics
 * 9. Edge runtime optimized
 * 10. Production security flags
 */
export async function POST(request: NextRequest): Promise<NextResponse> {
  const timer = createMetricsTimer();
  const clientIP = getClientIP(request);
  
  try {
    // 1. CSRF and Origin Validation
    const securityValidation = await AuthSecurityValidator.validateRequest(request, logger);
    if (!securityValidation.valid) {
      logger.warn('CSRF/Origin validation failed', {
        error: securityValidation.error,
        metadata: {
          clientIP,
          origin: request.headers.get('origin'),
          referer: request.headers.get('referer'),
        }
      });
      
      recordAPIMetrics({
        endpoint: '/api/auth/callback',
        method: 'POST',
        statusCode: 403,
        duration: timer(),
        error: 'csrf_validation_failed',
      });
      
      return NextResponse.json(
        { error: 'Invalid request origin or missing CSRF token' },
        { status: 403 }
      );
    }

    // 2. Rate Limiting - using enhanced rate limiting
    const rateLimitResult = await checkRateLimit(clientIP, 'notifications_per_ip');

    if (!rateLimitResult.allowed) {
      logger.warn('Rate limit exceeded', {
        metadata: {
          clientIP,
          remaining: rateLimitResult.remaining,
          resetTime: rateLimitResult.resetTime,
        }
      });

      recordAPIMetrics({
        endpoint: '/api/auth/callback',
        method: 'POST',
        statusCode: 429,
        duration: timer(),
        error: 'rate_limit_exceeded',
      });

      const response = NextResponse.json(
        { error: 'Too many requests' },
        { status: 429 }
      );
      
      response.headers.set('X-RateLimit-Limit', RATE_LIMIT_CONFIG.maxRequests.toString());
      response.headers.set('X-RateLimit-Remaining', rateLimitResult.remaining.toString());
      response.headers.set('X-RateLimit-Reset', Math.ceil(rateLimitResult.resetTime.getTime() / 1000).toString());
      
      return response;
    }

    // 3. Body Size and Schema Validation
    const bodyValidation = await AuthSecurityValidator.validateBody(request, logger);
    if (!bodyValidation.valid || !bodyValidation.body) {
      logger.warn('Body validation failed', {
        error: bodyValidation.error,
        metadata: { clientIP },
      });

      recordAPIMetrics({
        endpoint: '/api/auth/callback',
        method: 'POST',
        statusCode: 400,
        duration: timer(),
        error: 'invalid_payload',
      });

      return NextResponse.json(
        { error: bodyValidation.error !== null && bodyValidation.error !== undefined ? bodyValidation.error : 'Invalid request body' },
        { status: 400 }
      );
    }

    const { event, session }: AuthCallbackPayload = bodyValidation.body;

    // Structured logging (with PII protection)
    if (LOG_CONFIG.verbose) {
      logger.info('Auth callback processing', {
        metadata: {
          event,
          hasSession: Boolean(session),
          userId: session?.user?.id !== null && session?.user?.id !== undefined 
            ? `user_${session.user.id.substring(0, USER_ID_ANONYMIZATION_LENGTH)}***` 
            : undefined,
          clientIP,
        }
      });
    }

    // 4. Initialize Singleton Supabase Client with Secure Cookie Handler
    const response = NextResponse.json({ status: 'success' });
    const cookieStore = await cookies();
    const cookieAdapter = { get: async (name: string) => { const cookie = cookieStore.get(name); return cookie ? { value: cookie.value } : undefined; } }; const cookieHandler = createCookieHandler(cookieAdapter, response, LOG_CONFIG.verbose);
    const supabase = await getSupabaseSingleton(cookieHandler);

    // 5. Process Auth Events with Session Rollback
    type SessionResult = { user?: { id?: string } } | null;
    let sessionResult: SessionResult = null;

    if (event === 'SIGNED_IN' || event === 'TOKEN_REFRESHED') {
      if (!session) {
        logger.error('Session data missing for sign-in event', { 
          metadata: { event, clientIP }
        });
        
        recordAPIMetrics({
          endpoint: '/api/auth/callback',
          method: 'POST',
          statusCode: 400,
          duration: timer(),
          error: 'missing_session_data',
        });
        
        return NextResponse.json(
          { error: 'Session data required for sign-in events' },
          { status: 400 }
        );
      }

      // Set session with Supabase
      const setSessionResult = await supabase.auth.setSession(session);
      if (setSessionResult.error) {
        logger.error('Failed to set session', {
          error: setSessionResult.error.message,
          metadata: { event, clientIP },
        });

        recordAPIMetrics({
          endpoint: '/api/auth/callback',
          method: 'POST',
          statusCode: 500,
          duration: timer(),
          error: 'session_set_failed',
        });

        // Clear any potentially set cookies on failure
        SessionManager.clearAuthCookies(response);
        
        return NextResponse.json(
          { error: 'Failed to establish session' },
          { status: 500 }
        );
      }

      // 6. Session Integrity Validation with Rollback (optimized - no extra round-trip)
      const sessionValidation = SessionManager.validateSessionIntegrity(
        { data: { session: setSessionResult.data.session ? { user: setSessionResult.data.session.user } : undefined }, error: setSessionResult.error ? { message: setSessionResult.error.message } : undefined },
        session.user?.id
      );

      if (!sessionValidation.valid) {
        logger.error('Session validation failed after setting', {
          error: sessionValidation.error,
          metadata: { event, clientIP },
        });

        recordAPIMetrics({
          endpoint: '/api/auth/callback',
          method: 'POST',
          statusCode: 500,
          duration: timer(),
          error: 'session_validation_failed',
        });

        // Rollback: Clear all auth cookies
        SessionManager.clearAuthCookies(response);
        
        return NextResponse.json(
          { error: 'Session validation failed' },
          { status: 500 }
        );
      }

      sessionResult = sessionValidation.session as SessionResult;
      
      if (LOG_CONFIG.verbose) {
        logger.info('Session successfully established', {
          metadata: {
            event,
            sessionValid: true,
            clientIP,
          }
        });
      }

    } else if (event === 'SIGNED_OUT') {
      if (LOG_CONFIG.verbose) {
        logger.info('Processing sign-out', { metadata: { event, clientIP } });
      }

      const signOutResult = await supabase.auth.signOut();
      if (signOutResult.error) {
        logger.warn('Sign-out error (non-critical)', {
          error: signOutResult.error.message,
          metadata: { clientIP },
        });
      }

      // Ensure all auth cookies are cleared
      SessionManager.clearAuthCookies(response);
    }

    // 7. Enforce Cookie Security Flags in Production
    CookieSecurityManager.enforceSecurityFlags(response);

    // 8. Success Metrics and Logging
    const duration = timer();
    recordAPIMetrics({
      endpoint: '/api/auth/callback',
      method: 'POST',
      statusCode: 200,
      duration,
      userId: sessionResult?.user?.id,
    });

    if (LOG_CONFIG.verbose) {
      logger.info('Auth callback completed successfully', {
        metadata: {
          event,
          duration,
          clientIP,
        }
      });
    }

    return response;

  } catch (error: unknown) {
    // 9. Comprehensive Error Handling with Metrics
    const duration = timer();
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    
    logger.error('Auth callback unexpected error', {
      error: errorMessage,
      metadata: {
        clientIP,
        duration,
        stack: error instanceof Error ? error.stack : undefined,
      }
    });

    recordAPIMetrics({
      endpoint: '/api/auth/callback',
      method: 'POST',
      statusCode: 500,
      duration,
      error: 'unexpected_error',
    });

    // Create error response with cleared cookies
    const errorResponse = NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );

    // Clear potentially corrupted auth state
    SessionManager.clearAuthCookies(errorResponse);
    
    return errorResponse;
  }
}

// 10. Edge Runtime Declaration for Optimal Performance
export const runtime = 'edge';
