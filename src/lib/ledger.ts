import { supabaseAdmin } from '@/lib/supabaseAdmin';

export interface LedgerInsert {
  account_id: string;
  stripe_object_id: string;
  event_type: string;
  amount_cents: number; // signed integer: positive credit, negative debit
  currency: string;
  memo?: Record<string, unknown>;
}

/**
 * Atomically inserts a batch of ledger entries.
 *
 * Delegates to the `ledger_insert_batch` Postgres function which:
 *   1. Locks the target account row (FOR UPDATE).
 *   2. Increments the account's running balance.
 *   3. Persists an immutable row in accounting.ledger_entries.
 *   4. Guarantees idempotency via ON CONFLICT DO NOTHING.
 *
 * If Postgres returns an error the promise rejects, allowing upstream callers
 * (e.g. Stripe webhooks) to surface a 5xx and retry later.
 */
export async function insertLedgerEntries(
  entries: LedgerInsert[],
): Promise<void> {
  if (entries.length === 0) {
    return;
  }

  // `ledger_insert_batch` lives in the `accounting` schema, which is not
  // included in the autogenerated `Database["public"]["Functions"]` union.
  // We cast the *function name* to `never` so the generic constraint is
  // satisfied without loosening the type of `supabaseAdmin` or resorting to
  // `any`.
  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
  const { error } = await supabaseAdmin.rpc(
    'ledger_insert_batch' as never,
    { entries } as never,
  );

  if (error) {
    throw error;
  }
}
